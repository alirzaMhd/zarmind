backend\src\controllers\authController.ts = '// ==========================================
// ZARMIND - Authentication Controller
// ==========================================

import { Request, Response } from \'express\';
import { asyncHandler } from \'../middleware/error.middleware\';
import AuthService from \'../services/authService\';
import { getCurrentUserId, getCurrentUser, AuthenticatedRequest } from \'../middleware/auth.middleware\';
import { UnauthorizedError, ValidationError } from \'../types\';
import { COOKIE_CONFIG } from \'../config/server\';

// ==========================================
// HELPER FUNCTIONS
// ==========================================

/**
 * Set authentication cookies
 */
const setAuthCookies = (res: Response, accessToken: string, refreshToken: string): void => {
  // Access token cookie (short-lived)
  res.cookie(\'accessToken\', accessToken, {
    ...COOKIE_CONFIG.OPTIONS,
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });

  // Refresh token cookie (long-lived)
  res.cookie(\'refreshToken\', refreshToken, {
    ...COOKIE_CONFIG.OPTIONS,
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
  });
};

/**
 * Clear authentication cookies
 */
const clearAuthCookies = (res: Response): void => {
  res.clearCookie(\'accessToken\');
  res.clearCookie(\'refreshToken\');
};

/**
 * Extract access token from request
 */
const extractAccessToken = (req: Request): string | null => {
  // Try header first
  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith(\'Bearer \')) {
    const token = authHeader.split(\' \')[1];
    return token || null;
  }

  // Try cookie
  return req.cookies?.accessToken || req.signedCookies?.accessToken || null;
};

// ==========================================
// AUTHENTICATION CONTROLLERS
// ==========================================

/**
 * @route   POST /api/auth/login
 * @desc    Login user with username/password
 * @access  Public
 */
export const login = asyncHandler(async (req: Request, res: Response) => {
  const { username, password, rememberMe } = req.body;

  // Validate input
  if (!username || !password) {
    throw new ValidationError(\'نام کاربری و رمز عبور الزامی است\');
  }

  // Login user
  const result = await AuthService.login(
    { username, password, rememberMe },
    req.ip,
    req.get(\'user-agent\')
  );

  // Set cookies
  setAuthCookies(res, result.tokens.accessToken, result.tokens.refreshToken);

  // Send response
  res.sendSuccess(
    {
      user: result.user,
      accessToken: result.tokens.accessToken,
      refreshToken: result.tokens.refreshToken,
    },
    \'ورود موفقیت‌آمیز بود\'
  );
});

/**
 * @route   POST /api/auth/login-email
 * @desc    Login user with email/password
 * @access  Public
 */
export const loginWithEmail = asyncHandler(async (req: Request, res: Response) => {
  const { email, password } = req.body;

  // Validate input
  if (!email || !password) {
    throw new ValidationError(\'ایمیل و رمز عبور الزامی است\');
  }

  // Login user
  const result = await AuthService.loginWithEmail(
    email,
    password,
    req.ip,
    req.get(\'user-agent\')
  );

  // Set cookies
  setAuthCookies(res, result.tokens.accessToken, result.tokens.refreshToken);

  // Send response
  res.sendSuccess(
    {
      user: result.user,
      accessToken: result.tokens.accessToken,
      refreshToken: result.tokens.refreshToken,
    },
    \'ورود موفقیت‌آمیز بود\'
  );
});

/**
 * @route   POST /api/auth/register
 * @desc    Register new user
 * @access  Public (or Admin only for creating users)
 */
export const register = asyncHandler(async (req: Request, res: Response) => {
  const registerData = req.body;

  // Register user
  const result = await AuthService.register(
    registerData,
    req.ip,
    req.get(\'user-agent\')
  );

  // Set cookies
  setAuthCookies(res, result.tokens.accessToken, result.tokens.refreshToken);

  // Send response
  res.status(201).json({
    success: true,
    message: \'ثبت‌نام با موفقیت انجام شد\',
    data: {
      user: result.user,
      accessToken: result.tokens.accessToken,
      refreshToken: result.tokens.refreshToken,
    },
  });
});

/**
 * @route   POST /api/auth/logout
 * @desc    Logout user and blacklist token
 * @access  Private
 */
export const logout = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);
  const accessToken = extractAccessToken(req);

  if (accessToken) {
    await AuthService.logout(accessToken, userId, req.ip, req.get(\'user-agent\'));
  }

  // Clear cookies
  clearAuthCookies(res);

  res.sendSuccess(null, \'خروج با موفقیت انجام شد\');
});

/**
 * @route   POST /api/auth/refresh
 * @desc    Refresh access token using refresh token
 * @access  Public
 */
export const refreshToken = asyncHandler(async (req: Request, res: Response) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    throw new ValidationError(\'توکن بازیابی الزامی است\');
  }

  // Refresh tokens
  const tokens = await AuthService.refreshAccessToken({ refreshToken });

  // Set new cookies
  setAuthCookies(res, tokens.accessToken, tokens.refreshToken);

  res.sendSuccess(
    {
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
    },
    \'توکن با موفقیت بازیابی شد\'
  );
});

/**
 * @route   POST /api/auth/validate
 * @desc    Validate access token
 * @access  Public
 */
export const validateToken = asyncHandler(async (req: Request, res: Response) => {
  const { token } = req.body;

  if (!token) {
    throw new ValidationError(\'توکن الزامی است\');
  }

  const payload = await AuthService.validateToken(token);

  res.sendSuccess(
    {
      valid: true,
      payload,
    },
    \'توکن معتبر است\'
  );
});

// ==========================================
// PROFILE CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/me
 * @desc    Get current user profile
 * @access  Private
 */
export const getProfile = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const profile = await AuthService.getProfile(userId);

  res.sendSuccess(profile, \'اطلاعات پروفایل دریافت شد\');
});

/**
 * @route   PUT /api/auth/me
 * @desc    Update current user profile
 * @access  Private
 */
export const updateProfile = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const { full_name, phone, email, avatar } = req.body;

  const updatedProfile = await AuthService.updateProfile(userId, {
    full_name,
    phone,
    email,
    avatar,
  });

  res.sendSuccess(updatedProfile, \'پروفایل با موفقیت به‌روزرسانی شد\');
});

/**
 * @route   PUT /api/auth/avatar
 * @desc    Update user avatar
 * @access  Private
 */
export const updateAvatar = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  // Avatar URL should come from file upload middleware
  const avatarUrl = req.body.avatar || req.file?.path;

  if (!avatarUrl) {
    throw new ValidationError(\'فایل تصویر الزامی است\');
  }

  const updatedProfile = await AuthService.updateProfile(userId, {
    avatar: avatarUrl,
  });

  res.sendSuccess(updatedProfile, \'تصویر پروفایل با موفقیت به‌روزرسانی شد\');
});

// ==========================================
// PASSWORD CONTROLLERS
// ==========================================

/**
 * @route   PUT /api/auth/change-password
 * @desc    Change user password (requires current password)
 * @access  Private
 */
export const changePassword = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const { currentPassword, newPassword, confirmPassword } = req.body;

  // Validate input
  if (!currentPassword || !newPassword || !confirmPassword) {
    throw new ValidationError(\'تمام فیلدها الزامی هستند\');
  }

  await AuthService.changePassword({
    userId,
    currentPassword,
    newPassword,
    confirmPassword,
  });

  res.sendSuccess(null, \'رمز عبور با موفقیت تغییر کرد\');
});

/**
 * @route   POST /api/auth/forgot-password
 * @desc    Request password reset (send reset email)
 * @access  Public
 */
export const forgotPassword = asyncHandler(async (req: Request, res: Response) => {
  const { email } = req.body;

  if (!email) {
    throw new ValidationError(\'ایمیل الزامی است\');
  }

  const result = await AuthService.requestPasswordReset(email);

  // In production, only send message (hide resetToken)
  if (process.env.NODE_ENV === \'development\') {
    res.sendSuccess(result, result.message);
  } else {
    res.sendSuccess({ message: result.message }, result.message);
  }
});

/**
 * @route   POST /api/auth/reset-password
 * @desc    Reset password with reset token
 * @access  Public
 */
export const resetPassword = asyncHandler(async (req: Request, res: Response) => {
  const { resetToken, newPassword, confirmPassword } = req.body;

  if (!resetToken || !newPassword || !confirmPassword) {
    throw new ValidationError(\'تمام فیلدها الزامی هستند\');
  }

  if (newPassword !== confirmPassword) {
    throw new ValidationError(\'رمز عبور جدید و تکرار آن مطابقت ندارند\');
  }

  await AuthService.confirmPasswordReset(resetToken, newPassword);

  res.sendSuccess(null, \'رمز عبور با موفقیت بازیابی شد\');
});

/**
 * @route   PUT /api/auth/reset-password/:userId
 * @desc    Admin reset user password (no current password required)
 * @access  Private (Admin only)
 */
export const adminResetPassword = asyncHandler(async (req: Request, res: Response) => {
  const { userId } = req.params;
  const { newPassword } = req.body;

  // Validate userId exists
  if (!userId) {
    throw new ValidationError(\'شناسه کاربر الزامی است\');
  }

  if (!newPassword) {
    throw new ValidationError(\'رمز عبور جدید الزامی است\');
  }

  await AuthService.resetPassword({ userId, newPassword });

  res.sendSuccess(null, \'رمز عبور کاربر با موفقیت بازنشانی شد\');
});
// ==========================================
// ACCOUNT VERIFICATION CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/check-username/:username
 * @desc    Check if username is available
 * @access  Public
 */
export const checkUsername = asyncHandler(async (req: Request, res: Response) => {
  const { username } = req.params;

  if (!username) {
    throw new ValidationError(\'نام کاربری الزامی است\');
  }

  const isAvailable = await AuthService.checkUsernameAvailability(username);

  res.sendSuccess(
    {
      username,
      available: isAvailable,
    },
    isAvailable ? \'نام کاربری در دسترس است\' : \'نام کاربری قبلاً ثبت شده است\'
  );
});

/**
 * @route   GET /api/auth/check-email/:email
 * @desc    Check if email is available
 * @access  Public
 */
export const checkEmail = asyncHandler(async (req: Request, res: Response) => {
  const { email } = req.params;

  if (!email) {
    throw new ValidationError(\'ایمیل الزامی است\');
  }

  const isAvailable = await AuthService.checkEmailAvailability(email);

  res.sendSuccess(
    {
      email,
      available: isAvailable,
    },
    isAvailable ? \'ایمیل در دسترس است\' : \'ایمیل قبلاً ثبت شده است\'
  );
});

/**
 * @route   POST /api/auth/check-availability
 * @desc    Check username and email availability
 * @access  Public
 */
export const checkAvailability = asyncHandler(async (req: Request, res: Response) => {
  const { username, email } = req.body;

  const result: {
    username?: { value: string; available: boolean };
    email?: { value: string; available: boolean };
  } = {};

  if (username) {
    const usernameAvailable = await AuthService.checkUsernameAvailability(username);
    result.username = {
      value: username,
      available: usernameAvailable,
    };
  }

  if (email) {
    const emailAvailable = await AuthService.checkEmailAvailability(email);
    result.email = {
      value: email,
      available: emailAvailable,
    };
  }

  res.sendSuccess(result, \'بررسی در دسترس بودن انجام شد\');
});

// ==========================================
// SESSION MANAGEMENT CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/sessions
 * @desc    Get all active sessions for current user
 * @access  Private
 */
export const getSessions = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const sessions = await AuthService.getActiveSessions(userId);

  res.sendSuccess(sessions, \'لیست نشست‌های فعال دریافت شد\');
});

/**
 * @route   DELETE /api/auth/sessions
 * @desc    Revoke all sessions (logout from all devices)
 * @access  Private
 */
export const revokeSessions = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  await AuthService.revokeAllSessions(userId);

  // Clear current session cookies
  clearAuthCookies(res);

  res.sendSuccess(null, \'تمام نشست‌ها با موفقیت لغو شدند\');
});

// ==========================================
// SECURITY CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/login-history
 * @desc    Get user\'s recent login history
 * @access  Private
 */
export const getLoginHistory = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const limit = parseInt(req.query.limit as string) || 10;
  const history = await AuthService.getLoginHistory(userId, limit);

  res.sendSuccess(history, \'تاریخچه ورود دریافت شد\');
});

/**
 * @route   POST /api/auth/enable-2fa
 * @desc    Enable two-factor authentication
 * @access  Private
 */
export const enableTwoFactor = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  try {
    const result = await AuthService.enableTwoFactor(userId);
    res.sendSuccess(result, \'احراز هویت دو مرحله‌ای فعال شد\');
  } catch (error) {
    res.sendSuccess(
      null,
      \'احراز هویت دو مرحله‌ای هنوز پیاده‌سازی نشده است\'
    );
  }
});

/**
 * @route   POST /api/auth/verify-2fa
 * @desc    Verify two-factor authentication code
 * @access  Private
 */
export const verifyTwoFactor = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);
  const { code } = req.body;

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  if (!code) {
    throw new ValidationError(\'کد تایید الزامی است\');
  }

  try {
    const isValid = await AuthService.verifyTwoFactor(userId, code);
    res.sendSuccess({ valid: isValid }, \'کد تایید معتبر است\');
  } catch (error) {
    res.sendSuccess(
      null,
      \'احراز هویت دو مرحله‌ای هنوز پیاده‌سازی نشده است\'
    );
  }
});

// ==========================================
// UTILITY CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/verify
 * @desc    Verify if user is authenticated
 * @access  Private
 */
export const verifyAuthentication = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const user = getCurrentUser(req);

  if (!user) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  res.sendSuccess(
    {
      authenticated: true,
      user,
    },
    \'کاربر احراز هویت شده است\'
  );
});

/**
 * @route   GET /api/auth/status
 * @desc    Get authentication status and user info
 * @access  Public (with optional auth)
 */
export const getAuthStatus = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const user = getCurrentUser(req);

  res.sendSuccess({
    authenticated: !!user,
    user: user || null,
  });
});

// ==========================================
// EXPORTS
// ==========================================

export default {
  // Authentication
  login,
  loginWithEmail,
  register,
  logout,
  refreshToken,
  validateToken,

  // Profile
  getProfile,
  updateProfile,
  updateAvatar,

  // Password
  changePassword,
  forgotPassword,
  resetPassword,
  adminResetPassword,

  // Verification
  checkUsername,
  checkEmail,
  checkAvailability,

  // Sessions
  getSessions,
  revokeSessions,

  // Security
  getLoginHistory,
  enableTwoFactor,
  verifyTwoFactor,

  // Utility
  verifyAuthentication,
  getAuthStatus,
};'

backend\src\middleware\auth.middleware.ts = '// ==========================================
// ZARMIND - Authentication Middleware
// ==========================================

import { Request, Response, NextFunction } from \'express\';
import jwt from \'jsonwebtoken\';
import { JWT_CONFIG } from \'../config/server\';
import {
  ITokenPayload,
  UserRole,
  UnauthorizedError,
  ForbiddenError,
  IUser,
} from \'../types\';
import UserModel from \'../models/User\';
import logger, { logSecurity } from \'../utils/logger\';

// ==========================================
// INTERFACES
// ==========================================

export interface AuthenticatedRequest extends Request {
  user?: ITokenPayload;
  currentUser?: Omit<IUser, \'password\'>;
}

// ==========================================
// TOKEN EXTRACTION
// ==========================================

/**
 * Extract token from Authorization header
 */
const extractTokenFromHeader = (req: Request): string | null => {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return null;
  }

  // Check for "Bearer TOKEN" format
  const parts = authHeader.split(\' \');

  if (parts.length !== 2 || parts[0] !== \'Bearer\') {
    return null;
  }

  return parts[1] ?? null;
};

/**
 * Extract token from cookies
 */
const extractTokenFromCookie = (req: Request): string | null => {
  return req.cookies?.token || req.signedCookies?.token || null;
};

/**
 * Extract token from request (header or cookie)
 */
const extractToken = (req: Request): string | null => {
  // Try header first
  let token = extractTokenFromHeader(req);

  // Fallback to cookie
  if (!token) {
    token = extractTokenFromCookie(req);
  }

  return token;
};

// ==========================================
// TOKEN VERIFICATION
// ==========================================

/**
 * Verify JWT token
 */
const verifyToken = (token: string): ITokenPayload => {
  try {
    const decoded = jwt.verify(token, JWT_CONFIG.SECRET) as ITokenPayload;

    // Validate required fields
    if (!decoded.userId || !decoded.username || !decoded.role) {
      throw new UnauthorizedError(\'توکن نامعتبر است\');
    }

    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new UnauthorizedError(\'توکن منقضی شده است. لطفاً دوباره وارد شوید\');
    }

    if (error instanceof jwt.JsonWebTokenError) {
      throw new UnauthorizedError(\'توکن نامعتبر است\');
    }

    throw error;
  }
};

/**
 * Generate access token
 */
export const generateAccessToken = (user: IUser): string => {
  const payload: ITokenPayload = {
    userId: user.id,
    username: user.username,
    role: user.role,
  };

  return jwt.sign(payload, JWT_CONFIG.SECRET, {
    expiresIn: JWT_CONFIG.EXPIRE,
    issuer: JWT_CONFIG.ISSUER,
    audience: JWT_CONFIG.AUDIENCE,
  } as jwt.SignOptions);
};

/**
 * Generate refresh token
 */
export const generateRefreshToken = (user: IUser): string => {
  const payload: ITokenPayload = {
    userId: user.id,
    username: user.username,
    role: user.role,
  };

  return jwt.sign(payload, JWT_CONFIG.REFRESH_SECRET, {
    expiresIn: JWT_CONFIG.REFRESH_EXPIRE,
    issuer: JWT_CONFIG.ISSUER,
    audience: JWT_CONFIG.AUDIENCE,
  } as jwt.SignOptions);
};

/**
 * Verify refresh token
 */
export const verifyRefreshToken = (token: string): ITokenPayload => {
  try {
    const decoded = jwt.verify(token, JWT_CONFIG.REFRESH_SECRET) as ITokenPayload;

    if (!decoded.userId || !decoded.username || !decoded.role) {
      throw new UnauthorizedError(\'توکن بازیابی نامعتبر است\');
    }

    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new UnauthorizedError(\'توکن بازیابی منقضی شده است. لطفاً دوباره وارد شوید\');
    }

    throw new UnauthorizedError(\'توکن بازیابی نامعتبر است\');
  }
};

/**
 * Decode token without verification (for debugging)
 */
export const decodeToken = (token: string): ITokenPayload | null => {
  try {
    return jwt.decode(token) as ITokenPayload;
  } catch {
    return null;
  }
};

// ==========================================
// AUTHENTICATION MIDDLEWARE
// ==========================================

/**
 * Authenticate user - verify token and attach user to request
 * FIXED: Proper return statements to prevent double response
 */
export const authenticate = async (
  req: Request,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Extract token
    const token = extractToken(req);

    if (!token) {
      return next(new UnauthorizedError(\'توکن احراز هویت یافت نشد\'));
    }

    // Verify token
    const decoded = verifyToken(token);

    // Check if user still exists and is active
    const user = await UserModel.findById(decoded.userId);

    if (!user) {
      return next(new UnauthorizedError(\'کاربر یافت نشد\'));
    }

    if (!user.is_active) {
      logSecurity(\'Inactive user attempted access\', \'medium\', {
        userId: user.id,
        username: user.username,
        ip: req.ip,
      });
      return next(new UnauthorizedError(\'حساب کاربری غیرفعال است\'));
    }

    // Attach user info to request
    req.user = decoded;
    (req as AuthenticatedRequest).currentUser = UserModel.omitPassword(user);

    logger.debug(\'User authenticated\', {
      userId: decoded.userId,
      username: decoded.username,
      role: decoded.role,
      path: req.path,
    });

    next();
  } catch (error) {
    // Log failed authentication attempt
    logSecurity(\'Failed authentication attempt\', \'low\', {
      ip: req.ip,
      path: req.path,
      userAgent: req.get(\'user-agent\'),
      error: (error as Error).message,
    });

    next(error);
  }
};

/**
 * Optional authentication - attach user if token exists, but don\'t require it
 */
export const optionalAuthenticate = async (
  req: Request,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const token = extractToken(req);

    if (token) {
      const decoded = verifyToken(token);
      const user = await UserModel.findById(decoded.userId);

      if (user && user.is_active) {
        req.user = decoded;
        (req as AuthenticatedRequest).currentUser = UserModel.omitPassword(user);
      }
    }

    next();
  } catch (error) {
    // Silently fail for optional auth
    next();
  }
};

// ==========================================
// AUTHORIZATION MIDDLEWARE
// ==========================================

/**
 * Authorize user based on roles
 * FIXED: Proper return statements
 */
export const authorize = (...allowedRoles: UserRole[]) => {
  return (req: Request, _res: Response, next: NextFunction): void => {
    try {
      if (!req.user) {
        return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
      }

      const userRole = req.user.role;

      if (!allowedRoles.includes(userRole as UserRole)) {
        logSecurity(\'Unauthorized access attempt\', \'medium\', {
          userId: req.user.userId,
          username: req.user.username,
          role: userRole,
          requiredRoles: allowedRoles,
          path: req.path,
          ip: req.ip,
        });

        return next(new ForbiddenError(\'شما دسترسی به این بخش را ندارید\'));
      }

      logger.debug(\'User authorized\', {
        userId: req.user.userId,
        role: userRole,
        allowedRoles,
        path: req.path,
      });

      next();
    } catch (error) {
      next(error);
    }
  };
};

/**
 * Check if user is admin
 */
export const isAdmin = authorize(UserRole.ADMIN);

/**
 * Check if user is admin or manager
 */
export const isAdminOrManager = authorize(UserRole.ADMIN, UserRole.MANAGER);

/**
 * Check if user is admin, manager, or employee
 */
export const isEmployee = authorize(UserRole.ADMIN, UserRole.MANAGER, UserRole.EMPLOYEE);

/**
 * Allow all authenticated users (any role)
 */
export const isAuthenticated = authenticate;

// ==========================================
// OWNERSHIP MIDDLEWARE
// ==========================================

/**
 * Check if user owns the resource (by user ID in params)
 */
export const isOwner = (req: Request, _res: Response, next: NextFunction): void => {
  try {
    if (!req.user) {
      return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
    }

    const resourceUserId = req.params.userId || req.params.id;
    const currentUserId = req.user.userId;

    // Admin can access all resources
    if (req.user.role === UserRole.ADMIN) {
      return next();
    }

    // Check ownership
    if (resourceUserId !== currentUserId) {
      logSecurity(\'Ownership check failed\', \'medium\', {
        userId: currentUserId,
        requestedResourceUserId: resourceUserId,
        path: req.path,
        ip: req.ip,
      });

      return next(new ForbiddenError(\'شما فقط می‌توانید به اطلاعات خود دسترسی داشته باشید\'));
    }

    next();
  } catch (error) {
    next(error);
  }
};

/**
 * Check if user owns resource or has admin/manager role
 */
export const isOwnerOrManager = (req: Request, _res: Response, next: NextFunction): void => {
  try {
    if (!req.user) {
      return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
    }

    const resourceUserId = req.params.userId || req.params.id;
    const currentUserId = req.user.userId;
    const userRole = req.user.role as UserRole;

    // Admin or manager can access all resources
    if (userRole === UserRole.ADMIN || userRole === UserRole.MANAGER) {
      return next();
    }

    // Check ownership
    if (resourceUserId !== currentUserId) {
      return next(new ForbiddenError(\'شما دسترسی به این منبع را ندارید\'));
    }

    next();
  } catch (error) {
    next(error);
  }
};

// ==========================================
// CUSTOM AUTHORIZATION HELPERS
// ==========================================

/**
 * Check if user has specific permission
 */
export const hasPermission = (permission: string) => {
  return (req: Request, _res: Response, next: NextFunction): void => {
    try {
      if (!req.user) {
        return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
      }

      // Define permissions by role
      const rolePermissions: Record<UserRole, string[]> = {
        [UserRole.ADMIN]: [\'*\'], // All permissions
        [UserRole.MANAGER]: [
          \'users:read\',
          \'users:create\',
          \'users:update\',
          \'products:*\',
          \'customers:*\',
          \'sales:*\',
          \'reports:*\',
        ],
        [UserRole.EMPLOYEE]: [
          \'users:read:self\',
          \'products:read\',
          \'products:update\',
          \'customers:*\',
          \'sales:*\',
        ],
        [UserRole.VIEWER]: [
          \'users:read:self\',
          \'products:read\',
          \'customers:read\',
          \'sales:read\',
          \'reports:read\',
        ],
      };

      const userRole = req.user.role as UserRole;
      const permissions = rolePermissions[userRole] || [];

      // Check if user has permission
      const hasAccess =
        permissions.includes(\'*\') ||
        permissions.includes(permission) ||
        permissions.some((p) => {
          const [resource, action] = p.split(\':\');
          const [reqResource, reqAction] = permission.split(\':\');
          return resource === reqResource && (action === \'*\' || action === reqAction);
        });

      if (!hasAccess) {
        return next(new ForbiddenError(\'شما دسترسی به این عملیات را ندارید\'));
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};

/**
 * Check if user can modify resource based on creator
 */
export const canModify = (_createdByField: string = \'created_by\') => {
  return async (req: Request, _res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
      }

      const userRole = req.user.role as UserRole;

      // Admin can modify anything
      if (userRole === UserRole.ADMIN) {
        return next();
      }

      // For other roles, check if they created the resource
      // This should be implemented based on your resource logic
      // For now, managers can modify anything, others only their own
      if (userRole === UserRole.MANAGER) {
        return next();
      }

      // Employees can only modify their own resources
      // You would typically fetch the resource and check created_by
      // Example: const resource = await Model.findById(req.params.id);
      // if (resource[createdByField] !== currentUserId) { throw error }

      next();
    } catch (error) {
      next(error);
    }
  };
};

// ==========================================
// TOKEN BLACKLIST (Optional - for logout)
// ==========================================

// In-memory blacklist (in production, use Redis)
const tokenBlacklist = new Set<string>();

/**
 * Add token to blacklist
 */
export const blacklistToken = (token: string): void => {
  tokenBlacklist.add(token);
  logger.info(\'Token blacklisted\', { token: token.substring(0, 20) + \'...\' });
};

/**
 * Check if token is blacklisted
 */
export const isTokenBlacklisted = (token: string): boolean => {
  return tokenBlacklist.has(token);
};

/**
 * Middleware to check token blacklist
 */
export const checkBlacklist = (req: Request, _res: Response, next: NextFunction): void => {
  try {
    const token = extractToken(req);

    if (token && isTokenBlacklisted(token)) {
      return next(new UnauthorizedError(\'توکن نامعتبر است\'));
    }

    next();
  } catch (error) {
    next(error);
  }
};

// ==========================================
// LOGIN ATTEMPT TRACKING (Rate Limiting)
// ==========================================

// Track failed login attempts (in production, use Redis)
const loginAttempts = new Map<string, { count: number; lastAttempt: Date }>();

/**
 * Track failed login attempt
 */
export const trackFailedLogin = (identifier: string): void => {
  const attempts = loginAttempts.get(identifier) || { count: 0, lastAttempt: new Date() };
  attempts.count += 1;
  attempts.lastAttempt = new Date();
  loginAttempts.set(identifier, attempts);

  logSecurity(\'Failed login attempt\', \'low\', {
    identifier,
    attempts: attempts.count,
  });
};

/**
 * Reset login attempts on successful login
 */
export const resetLoginAttempts = (identifier: string): void => {
  loginAttempts.delete(identifier);
};

/**
 * Check if account is locked due to too many failed attempts
 */
export const isAccountLocked = (identifier: string): boolean => {
  const attempts = loginAttempts.get(identifier);

  if (!attempts) {
    return false;
  }

  // Lock after 5 failed attempts
  if (attempts.count >= 5) {
    // Check if lock period (15 minutes) has passed
    const lockDuration = 15 * 60 * 1000; // 15 minutes
    const timeSinceLastAttempt = Date.now() - attempts.lastAttempt.getTime();

    if (timeSinceLastAttempt < lockDuration) {
      return true;
    } else {
      // Lock period expired, reset attempts
      loginAttempts.delete(identifier);
      return false;
    }
  }

  return false;
};

/**
 * Middleware to check account lock status
 */
export const checkAccountLock = (identifierField: string = \'username\') => {
  return (req: Request, _res: Response, next: NextFunction): void => {
    try {
      const identifier = req.body[identifierField];

      if (identifier && isAccountLocked(identifier)) {
        logSecurity(\'Locked account access attempt\', \'high\', {
          identifier,
          ip: req.ip,
        });

        return next(new UnauthorizedError(
          \'حساب کاربری به دلیل تلاش‌های متعدد ناموفق قفل شده است. لطفاً 15 دقیقه صبر کنید\'
        ));
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};

// ==========================================
// MIDDLEWARE COMBINATIONS
// ==========================================

/**
 * Protect route - require authentication
 */
export const protect = authenticate;

/**
 * Protect route with role-based access
 */
export const protectWithRole = (...roles: UserRole[]) => {
  return [authenticate, authorize(...roles)];
};

/**
 * Protect route and check ownership
 */
export const protectOwn = [authenticate, isOwner];

/**
 * Protect route and check ownership or manager role
 */
export const protectOwnOrManager = [authenticate, isOwnerOrManager];

// ==========================================
// UTILITY FUNCTIONS
// ==========================================

/**
 * Get current user from request
 */
export const getCurrentUser = (req: AuthenticatedRequest): ITokenPayload | undefined => {
  return req.user;
};

/**
 * Require and return user ID (throw if not authenticated)
 */
export const requireUserId = (req: Request): string => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }
  return userId;
};

/**
 * Get current user ID from request
 */
export const getCurrentUserId = (req: Request): string | undefined => {
  return req.user?.userId;
};

/**
 * Get current user role from request
 */
export const getCurrentUserRole = (req: Request): UserRole | undefined => {
  return req.user?.role as UserRole;
};

/**
 * Check if current user is admin
 */
export const isCurrentUserAdmin = (req: Request): boolean => {
  return req.user?.role === UserRole.ADMIN;
};

/**
 * Check if current user is manager or admin
 */
export const isCurrentUserManagerOrAdmin = (req: Request): boolean => {
  const role = req.user?.role as UserRole;
  return role === UserRole.ADMIN || role === UserRole.MANAGER;
};

// ==========================================
// EXPORTS
// ==========================================

export default {
  // Main middleware
  authenticate,
  optionalAuthenticate,
  authorize,
  
  // Role-based
  isAdmin,
  isAdminOrManager,
  isEmployee,
  isAuthenticated,
  
  // Ownership
  isOwner,
  isOwnerOrManager,
  
  // Custom
  hasPermission,
  canModify,
  
  // Blacklist
  checkBlacklist,
  blacklistToken,
  isTokenBlacklisted,
  
  // Login attempts
  checkAccountLock,
  trackFailedLogin,
  resetLoginAttempts,
  isAccountLocked,
  
  // Combinations
  protect,
  protectWithRole,
  protectOwn,
  protectOwnOrManager,
  
  // Token operations
  generateAccessToken,
  generateRefreshToken,
  verifyRefreshToken,
  decodeToken,
  
  // Utilities
  getCurrentUser,
  getCurrentUserId,
  getCurrentUserRole,
  requireUserId,
  isCurrentUserAdmin,
  isCurrentUserManagerOrAdmin,
};'

backend\src\middleware\error.middleware.ts = '// ==========================================
// ZARMIND - Error Handling Middleware
// ==========================================

import { Request, Response, NextFunction } from \'express\';
import { MulterError } from \'multer\';
import { JsonWebTokenError, TokenExpiredError } from \'jsonwebtoken\';
import { StatusCodes } from \'http-status-codes\';
import {
  AppError,
  ValidationError,
  UnauthorizedError,
  NotFoundError,
  ConflictError,
  IValidationError,
  IApiResponse,
} from \'../types\';
import logger, { logError } from \'../utils/logger\';
import { IS_PRODUCTION } from \'../config/server\';

// ==========================================
// ERROR MESSAGES (Persian & English)
// ==========================================

const ERROR_MESSAGES = {
  INTERNAL_SERVER_ERROR: {
    fa: \'خطای داخلی سرور\',
    en: \'Internal server error\',
  },
  NOT_FOUND: {
    fa: \'صفحه یا منبع مورد نظر یافت نشد\',
    en: \'The requested resource was not found\',
  },
  UNAUTHORIZED: {
    fa: \'احراز هویت انجام نشده است\',
    en: \'Unauthorized - Authentication required\',
  },
  FORBIDDEN: {
    fa: \'دسترسی به این منبع ممنوع است\',
    en: \'Forbidden - Access denied\',
  },
  VALIDATION_ERROR: {
    fa: \'اطلاعات وارد شده نامعتبر است\',
    en: \'Validation error\',
  },
  TOKEN_EXPIRED: {
    fa: \'توکن منقضی شده است. لطفاً دوباره وارد شوید\',
    en: \'Token expired - Please login again\',
  },
  INVALID_TOKEN: {
    fa: \'توکن نامعتبر است\',
    en: \'Invalid token\',
  },
  DATABASE_ERROR: {
    fa: \'خطا در ارتباط با پایگاه داده\',
    en: \'Database error\',
  },
  FILE_TOO_LARGE: {
    fa: \'حجم فایل بیش از حد مجاز است\',
    en: \'File too large\',
  },
  INVALID_FILE_TYPE: {
    fa: \'نوع فایل مجاز نیست\',
    en: \'Invalid file type\',
  },
  DUPLICATE_KEY: {
    fa: \'این رکورد قبلاً ثبت شده است\',
    en: \'Duplicate entry\',
  },
  FOREIGN_KEY_VIOLATION: {
    fa: \'نمی‌توان این رکورد را حذف کرد. ارجاع‌های وابسته موجود است\',
    en: \'Cannot delete - Foreign key constraint violation\',
  },
  CONFLICT: {
    fa: \'تعارض در داده‌ها\',
    en: \'Data conflict\',
  },
} as const;

// ==========================================
// ASYNC ERROR WRAPPER
// ==========================================

/**
 * Wrapper for async route handlers to catch errors
 * Usage: router.get(\'/path\', asyncHandler(async (req, res) => { ... }))
 */
export const asyncHandler = <T = Request>(
  fn: (req: T, res: Response, next: NextFunction) => Promise<any>
) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req as T, res, next)).catch(next);
  };
};

// ==========================================
// 404 NOT FOUND HANDLER
// ==========================================

/**
 * Handle 404 - Not Found errors
 * Should be placed after all routes
 */
export const notFoundHandler = (
  req: Request,
  _res: Response,
  next: NextFunction
): void => {
  const error = new NotFoundError(
    `Route not found: ${req.method} ${req.originalUrl}`
  );
  
  logError(error, \'NotFoundHandler\', {
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
  });
  
  next(error);
};

// ==========================================
// HANDLE SPECIFIC ERROR TYPES
// ==========================================

/**
 * Handle JWT errors
 */
const handleJWTError = (error: JsonWebTokenError | TokenExpiredError): AppError => {
  if (error instanceof TokenExpiredError) {
    return new UnauthorizedError(ERROR_MESSAGES.TOKEN_EXPIRED.fa);
  }
  return new UnauthorizedError(ERROR_MESSAGES.INVALID_TOKEN.fa);
};

/**
 * Handle Multer (file upload) errors
 */
const handleMulterError = (error: MulterError): AppError => {
  if (error.code === \'LIMIT_FILE_SIZE\') {
    return new AppError(ERROR_MESSAGES.FILE_TOO_LARGE.fa, StatusCodes.BAD_REQUEST);
  }
  if (error.code === \'LIMIT_UNEXPECTED_FILE\') {
    return new AppError(ERROR_MESSAGES.INVALID_FILE_TYPE.fa, StatusCodes.BAD_REQUEST);
  }
  return new AppError(error.message, StatusCodes.BAD_REQUEST);
};

/**
 * Handle PostgreSQL database errors
 */
const handleDatabaseError = (error: any): AppError => {
  // Unique violation (23505)
  if (error.code === \'23505\') {
    const field = error.detail?.match(/KATEX_INLINE_OPEN(.+)KATEX_INLINE_CLOSE=/)?.[1] || \'field\';
    return new ConflictError(
      `${ERROR_MESSAGES.DUPLICATE_KEY.fa} (${field})`
    );
  }
  
  // Foreign key violation (23503)
  if (error.code === \'23503\') {
    return new AppError(
      ERROR_MESSAGES.FOREIGN_KEY_VIOLATION.fa,
      StatusCodes.CONFLICT
    );
  }
  
  // Not null violation (23502)
  if (error.code === \'23502\') {
    const column = error.column || \'unknown\';
    return new AppError(
      `فیلد ${column} الزامی است`,
      StatusCodes.BAD_REQUEST
    );
  }
  
  // Check violation (23514)
  if (error.code === \'23514\') {
    return new AppError(
      \'مقدار وارد شده نامعتبر است\',
      StatusCodes.BAD_REQUEST
    );
  }
  
  // Connection errors
  if (error.code === \'ECONNREFUSED\' || error.code === \'ENOTFOUND\') {
    return new AppError(
      ERROR_MESSAGES.DATABASE_ERROR.fa,
      StatusCodes.SERVICE_UNAVAILABLE
    );
  }
  
  // Generic database error
  return new AppError(
    ERROR_MESSAGES.DATABASE_ERROR.fa,
    StatusCodes.INTERNAL_SERVER_ERROR
  );
};

/**
 * Handle syntax errors (invalid JSON, etc.)
 */
const handleSyntaxError = (_error: SyntaxError): AppError => {
  return new AppError(
    \'فرمت داده‌های ارسالی نامعتبر است\',
    StatusCodes.BAD_REQUEST
  );
};

// ==========================================
// SEND ERROR RESPONSE
// ==========================================

/**
 * Send error response based on environment
 * FIXED: Added safety check for headers already sent
 */
const sendErrorResponse = (
  error: AppError,
  req: Request,
  res: Response
): void => {
  // ✅ CRITICAL: Prevent sending response if headers already sent
  if (res.headersSent) {
    logger.warn(\'[sendErrorResponse] Response already sent, cannot send error\', {
      error: error.message,
      path: req.originalUrl,
    });
    return;
  }
  
  const statusCode = error.statusCode || StatusCodes.INTERNAL_SERVER_ERROR;
  
  // Base error response
  const errorResponse: IApiResponse = {
    success: false,
    error: error.message,
  };
  
  // Add validation errors if available
  if (error instanceof ValidationError && error.errors?.length > 0) {
    errorResponse.errors = error.errors;
  }
  
  // In development, include stack trace and additional info
  if (!IS_PRODUCTION) {
    (errorResponse as any).stack = error.stack;
    (errorResponse as any).statusCode = statusCode;
    (errorResponse as any).path = req.originalUrl;
    (errorResponse as any).method = req.method;
    (errorResponse as any).timestamp = new Date().toISOString();
  }
  
  res.status(statusCode).json(errorResponse);
};

// ==========================================
// MAIN ERROR HANDLER MIDDLEWARE
// ==========================================

/**
 * Central error handling middleware
 * Should be placed after all routes and other middleware
 * FIXED: Added safety check at the very start
 */
export const errorHandler = (
  err: Error | AppError,
  req: Request,
  res: Response,
  _next: NextFunction
): void => {
  // ✅ CRITICAL FIX: Prevent double response
  if (res.headersSent) {
    logger.error(\'[ErrorHandler] Headers already sent, skipping error response\', {
      error: err.message,
      path: req.originalUrl,
      method: req.method,
    });
    return;
  }
  
  let error: AppError;
  
  // Handle different error types
  if (err instanceof AppError) {
    error = err;
  } else if (err instanceof JsonWebTokenError || err instanceof TokenExpiredError) {
    error = handleJWTError(err);
  } else if (err instanceof MulterError) {
    error = handleMulterError(err);
  } else if (err instanceof SyntaxError) {
    error = handleSyntaxError(err);
  } else if (\'code\' in err) {
    // Database errors
    error = handleDatabaseError(err);
  } else {
    // Generic error
    error = new AppError(
      IS_PRODUCTION
        ? ERROR_MESSAGES.INTERNAL_SERVER_ERROR.fa
        : err.message,
      StatusCodes.INTERNAL_SERVER_ERROR
    );
  }
  
  // Log error
  logError(err, \'ErrorHandler\', {
    statusCode: error.statusCode,
    path: req.originalUrl,
    method: req.method,
    ip: req.ip,
    user: req.user?.userId,
    body: req.method !== \'GET\' ? req.body : undefined,
    query: req.query,
  });
  
  // Send error response
  sendErrorResponse(error, req, res);
};

// ==========================================
// OPERATIONAL ERROR CHECKER
// ==========================================

/**
 * Check if error is operational (known/expected) or programming error
 */
export const isOperationalError = (error: Error | AppError): boolean => {
  if (error instanceof AppError) {
    return error.isOperational;
  }
  return false;
};

// ==========================================
// HANDLE UNHANDLED REJECTIONS & EXCEPTIONS
// ==========================================

/**
 * Handle unhandled promise rejections
 * FIXED: Don\'t crash in development
 */
export const handleUnhandledRejection = (reason: Error, promise: Promise<any>): void => {
  logError(reason, \'UnhandledRejection\', {
    promise: promise.toString(),
  });
  
  // In production, gracefully shutdown
  if (IS_PRODUCTION) {
    logger.error(\'Unhandled Rejection - Shutting down gracefully...\');
    process.exit(1);
  } else {
    logger.warn(\'Unhandled Rejection in development - continuing...\', {
      reason: reason.message,
      stack: reason.stack,
    });
  }
};

/**
 * Handle uncaught exceptions
 * FIXED: Don\'t crash in development
 */
export const handleUncaughtException = (error: Error): void => {
  logError(error, \'UncaughtException\');
  
  // Always log, but only exit in production
  if (IS_PRODUCTION) {
    logger.error(\'Uncaught Exception - Shutting down immediately...\');
    process.exit(1);
  } else {
    logger.error(\'Uncaught Exception in development - continuing...\', {
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack,
      },
    });
  }
};

// ==========================================
// VALIDATION ERROR BUILDER
// ==========================================

/**
 * Build validation error from express-validator errors
 */
export const buildValidationError = (
  errors: Array<{ param: string; msg: string; value?: any }>
): ValidationError => {
  const validationErrors: IValidationError[] = errors.map((err) => ({
    field: err.param,
    message: err.msg,
  }));
  
  return new ValidationError(
    ERROR_MESSAGES.VALIDATION_ERROR.fa,
    validationErrors
  );
};

/**
 * Build validation error from Joi validation result
 */
export const buildJoiValidationError = (joiError: any): ValidationError => {
  const validationErrors: IValidationError[] = joiError.details?.map((detail: any) => ({
    field: detail.path.join(\'.\'),
    message: detail.message,
  })) || [];
  
  return new ValidationError(
    ERROR_MESSAGES.VALIDATION_ERROR.fa,
    validationErrors
  );
};

// ==========================================
// ERROR RESPONSE HELPERS
// ==========================================

/**
 * Send success response
 * FIXED: Added safety check
 */
export const sendSuccess = <T = any>(
  res: Response,
  data?: T,
  message?: string,
  statusCode: number = StatusCodes.OK,
  meta?: any
): Response => {
  if (res.headersSent) {
    logger.warn(\'[sendSuccess] Headers already sent\');
    return res;
  }
  
  const response: IApiResponse<T> = {
    success: true,
    data,
    message,
    meta,
  };
  
  return res.status(statusCode).json(response);
};

/**
 * Send error response
 * FIXED: Added safety check
 */
export const sendError = (
  res: Response,
  message: string,
  statusCode: number = StatusCodes.BAD_REQUEST,
  errors?: IValidationError[]
): Response => {
  if (res.headersSent) {
    logger.warn(\'[sendError] Headers already sent\');
    return res;
  }
  
  const response: IApiResponse = {
    success: false,
    error: message,
    errors,
  };
  
  return res.status(statusCode).json(response);
};

/**
 * Send created response (201)
 */
export const sendCreated = <T = any>(
  res: Response,
  data: T,
  message?: string
): Response => {
  return sendSuccess(res, data, message, StatusCodes.CREATED);
};

/**
 * Send no content response (204)
 */
export const sendNoContent = (res: Response): Response => {
  if (res.headersSent) {
    logger.warn(\'[sendNoContent] Headers already sent\');
    return res;
  }
  return res.status(StatusCodes.NO_CONTENT).send();
};

// ==========================================
// ATTACH HELPERS TO RESPONSE OBJECT
// ==========================================

/**
 * Middleware to attach helper methods to response object
 */
export const attachResponseHelpers = (
  _req: Request,
  res: Response,
  next: NextFunction
): void => {
  // Attach sendSuccess method
  res.sendSuccess = function <T = any>(
    data?: T,
    message?: string,
    meta?: any
  ): Response {
    return sendSuccess(res, data, message, StatusCodes.OK, meta);
  };
  
  // Attach sendError method
  res.sendError = function (
    message: string,
    statusCode: number = StatusCodes.BAD_REQUEST,
    errors?: IValidationError[]
  ): Response {
    return sendError(res, message, statusCode, errors);
  };
  
  next();
};

// ==========================================
// REQUEST ID MIDDLEWARE
// ==========================================

/**
 * Add unique request ID to each request
 * FIXED: Safe header setting with try-catch
 */
export const requestIdMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  req.requestId = requestId;
  
  // Set header safely
  try {
    if (!res.headersSent) {
      res.setHeader(\'X-Request-ID\', requestId);
    }
  } catch (err) {
    // Silently ignore if headers already sent
    logger.debug(\'Could not set X-Request-ID header\', { requestId });
  }
  
  next();
};

// ==========================================
// REQUEST TIMING MIDDLEWARE (COMPLETELY REWRITTEN)
// ==========================================

/**
 * Track request processing time
 * FIXED: Use \'finish\' event instead of overriding res.end
 */
export const requestTimingMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const startTime = Date.now();
  req.startTime = startTime;
  
  // Listen for response finish event
  const onFinish = () => {
    const duration = Date.now() - startTime;
    
    // Log request completion
    const logData = {
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.get(\'user-agent\'),
      requestId: req.requestId,
      user: req.user?.userId,
    };
    
    // Log based on status code and duration
    if (res.statusCode >= 500) {
      logger.error(\'Request failed (5xx)\', logData);
    } else if (res.statusCode >= 400) {
      logger.warn(\'Request error (4xx)\', logData);
    } else if (duration > 1000) {
      logger.warn(\'Slow request (>1s)\', logData);
    } else {
      logger.http(`${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms`);
    }
  };
  
  // Attach finish listener
  res.on(\'finish\', onFinish);
  
  // Clean up listener on close
  res.on(\'close\', () => {
    res.off(\'finish\', onFinish);
  });
  
  next();
};

// ==========================================
// EXPORTS
// ==========================================

export default {
  asyncHandler,
  errorHandler,
  notFoundHandler,
  attachResponseHelpers,
  requestIdMiddleware,
  requestTimingMiddleware,
  sendSuccess,
  sendError,
  sendCreated,
  sendNoContent,
  buildValidationError,
  buildJoiValidationError,
  isOperationalError,
  handleUnhandledRejection,
  handleUncaughtException,
};

// ==========================================
// SETUP GLOBAL ERROR HANDLERS
// ==========================================

if (process.env.NODE_ENV !== \'test\') {
  // Handle unhandled promise rejections
  process.on(\'unhandledRejection\', handleUnhandledRejection);
  
  // Handle uncaught exceptions
  process.on(\'uncaughtException\', handleUncaughtException);
}'

backend\src\models\User.ts = '// ==========================================
// ZARMIND - User Model
// ==========================================

import { query } from \'../config/database\';
import { IUser, UserRole } from \'../types\';
import * as bcrypt from \'bcryptjs\';
import { BCRYPT_CONFIG } from \'../config/server\';
import { NotFoundError, ConflictError, ValidationError } from \'../types\';
import logger from \'../utils/logger\';

// ==========================================
// INTERFACES
// ==========================================

export interface ICreateUser {
  username: string;
  email: string;
  password: string;
  full_name: string;
  role?: UserRole;
  phone?: string;
  avatar?: string;
  is_active?: boolean;
}

export interface IUpdateUser {
  email?: string;
  full_name?: string;
  role?: UserRole;
  phone?: string;
  avatar?: string;
  is_active?: boolean;
}

export interface IUserFilter {
  role?: UserRole;
  is_active?: boolean;
  search?: string;
}

// ==========================================
// USER MODEL
// ==========================================

class UserModel {
  private tableName = \'users\';

  // ==========================================
  // CREATE
  // ==========================================

  /**
   * Create a new user
   */
  async create(userData: ICreateUser): Promise<IUser> {
    try {
      // Check if username already exists
      const existingUsername = await this.findByUsername(userData.username);
      if (existingUsername) {
        throw new ConflictError(`نام کاربری "${userData.username}" قبلاً ثبت شده است`);
      }

      // Check if email already exists
      const existingEmail = await this.findByEmail(userData.email);
      if (existingEmail) {
        throw new ConflictError(`ایمیل "${userData.email}" قبلاً ثبت شده است`);
      }

      // Hash password
      const hashedPassword = await this.hashPassword(userData.password);

      // Prepare user data
      const userToInsert = {
        username: userData.username,
        email: userData.email,
        password: hashedPassword,
        full_name: userData.full_name,
        role: userData.role || UserRole.EMPLOYEE,
        phone: userData.phone || null,
        avatar: userData.avatar || null,
        is_active: userData.is_active !== undefined ? userData.is_active : true,
      };

      // Insert user
      const result = await query(
        `INSERT INTO ${this.tableName} 
        (username, email, password, full_name, role, phone, avatar, is_active)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING *`,
        [
          userToInsert.username,
          userToInsert.email,
          userToInsert.password,
          userToInsert.full_name,
          userToInsert.role,
          userToInsert.phone,
          userToInsert.avatar,
          userToInsert.is_active,
        ]
      );

      const user = result.rows[0];
      logger.info(`User created: ${user.username} (${user.id})`);

      return user;
    } catch (error) {
      logger.error(\'Error creating user:\', error);
      throw error;
    }
  }

  // ==========================================
  // READ
  // ==========================================

  /**
   * Find user by ID
   */
  async findById(id: string): Promise<IUser | null> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE id = $1`,
      [id]
    );

    return result.rows[0] || null;
  }

  /**
   * Find user by username
   */
  async findByUsername(username: string): Promise<IUser | null> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE username = $1`,
      [username]
    );

    return result.rows[0] || null;
  }

  /**
   * Find user by email
   */
  async findByEmail(email: string): Promise<IUser | null> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE email = $1`,
      [email]
    );

    return result.rows[0] || null;
  }

  /**
   * Get all users with optional filters
   */
  async findAll(filters?: IUserFilter): Promise<IUser[]> {
    let sql = `SELECT * FROM ${this.tableName} WHERE 1=1`;
    const params: any[] = [];
    let paramIndex = 1;

    // Apply filters
    if (filters?.role) {
      sql += ` AND role = $${paramIndex}`;
      params.push(filters.role);
      paramIndex++;
    }

    if (filters?.is_active !== undefined) {
      sql += ` AND is_active = $${paramIndex}`;
      params.push(filters.is_active);
      paramIndex++;
    }

    if (filters?.search) {
      sql += ` AND (
        username ILIKE $${paramIndex} OR 
        email ILIKE $${paramIndex} OR 
        full_name ILIKE $${paramIndex}
      )`;
      params.push(`%${filters.search}%`);
      paramIndex++;
    }

    sql += ` ORDER BY created_at DESC`;

    const result = await query(sql, params);
    return result.rows;
  }

  /**
   * Get users with pagination
   */
  async findWithPagination(
    page: number = 1,
    limit: number = 20,
    filters?: IUserFilter
  ): Promise<{ users: IUser[]; total: number; page: number; limit: number }> {
    const offset = (page - 1) * limit;

    let countSql = `SELECT COUNT(*) as count FROM ${this.tableName} WHERE 1=1`;
    let dataSql = `SELECT * FROM ${this.tableName} WHERE 1=1`;
    const params: any[] = [];
    let paramIndex = 1;

    // Apply filters
    if (filters?.role) {
      const roleFilter = ` AND role = $${paramIndex}`;
      countSql += roleFilter;
      dataSql += roleFilter;
      params.push(filters.role);
      paramIndex++;
    }

    if (filters?.is_active !== undefined) {
      const activeFilter = ` AND is_active = $${paramIndex}`;
      countSql += activeFilter;
      dataSql += activeFilter;
      params.push(filters.is_active);
      paramIndex++;
    }

    if (filters?.search) {
      const searchFilter = ` AND (
        username ILIKE $${paramIndex} OR 
        email ILIKE $${paramIndex} OR 
        full_name ILIKE $${paramIndex}
      )`;
      countSql += searchFilter;
      dataSql += searchFilter;
      params.push(`%${filters.search}%`);
      paramIndex++;
    }

    dataSql += ` ORDER BY created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    const dataParams = [...params, limit, offset];

    // Execute queries
    const [countResult, dataResult] = await Promise.all([
      query(countSql, params),
      query(dataSql, dataParams),
    ]);

    const total = parseInt(countResult.rows[0]?.count || \'0\', 10);

    return {
      users: dataResult.rows,
      total,
      page,
      limit,
    };
  }

  /**
   * Get users by role
   */
  async findByRole(role: UserRole): Promise<IUser[]> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE role = $1 ORDER BY created_at DESC`,
      [role]
    );

    return result.rows;
  }

  /**
   * Get active users count
   */
  async getActiveUsersCount(): Promise<number> {
    const result = await query(
      `SELECT COUNT(*) as count FROM ${this.tableName} WHERE is_active = true`
    );

    return parseInt(result.rows[0]?.count || \'0\', 10);
  }

  /**
   * Get users count by role
   */
  async getUsersCountByRole(): Promise<Record<UserRole, number>> {
    const result = await query(
      `SELECT role, COUNT(*) as count 
     FROM ${this.tableName} 
     GROUP BY role`
    );

    const counts: Record<UserRole, number> = {
      [UserRole.ADMIN]: 0,
      [UserRole.MANAGER]: 0,
      [UserRole.EMPLOYEE]: 0,
      [UserRole.VIEWER]: 0,
    };

    result.rows.forEach((row: { role: string; count: string }) => {
      const role = row.role as UserRole;
      if (role in counts) {
        counts[role] = parseInt(row.count, 10);
      }
    });

    return counts;
  }

  // ==========================================
  // UPDATE
  // ==========================================

  /**
   * Update user by ID
   */
  async update(id: string, updateData: IUpdateUser): Promise<IUser> {
    const user = await this.findById(id);
    if (!user) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    // Check if email is being changed and if it\'s already taken
    if (updateData.email && updateData.email !== user.email) {
      const existingEmail = await this.findByEmail(updateData.email);
      if (existingEmail) {
        throw new ConflictError(`ایمیل "${updateData.email}" قبلاً ثبت شده است`);
      }
    }

    // Build update query
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    if (updateData.email !== undefined) {
      fields.push(`email = $${paramIndex}`);
      values.push(updateData.email);
      paramIndex++;
    }

    if (updateData.full_name !== undefined) {
      fields.push(`full_name = $${paramIndex}`);
      values.push(updateData.full_name);
      paramIndex++;
    }

    if (updateData.role !== undefined) {
      fields.push(`role = $${paramIndex}`);
      values.push(updateData.role);
      paramIndex++;
    }

    if (updateData.phone !== undefined) {
      fields.push(`phone = $${paramIndex}`);
      values.push(updateData.phone);
      paramIndex++;
    }

    if (updateData.avatar !== undefined) {
      fields.push(`avatar = $${paramIndex}`);
      values.push(updateData.avatar);
      paramIndex++;
    }

    if (updateData.is_active !== undefined) {
      fields.push(`is_active = $${paramIndex}`);
      values.push(updateData.is_active);
      paramIndex++;
    }

    if (fields.length === 0) {
      return user; // No changes
    }

    fields.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id);

    const sql = `
      UPDATE ${this.tableName} 
      SET ${fields.join(\', \')} 
      WHERE id = $${paramIndex}
      RETURNING *
    `;

    const result = await query(sql, values);
    const updatedUser = result.rows[0];

    logger.info(`User updated: ${updatedUser.username} (${updatedUser.id})`);

    return updatedUser;
  }

  /**
   * Update user password
   */
  async updatePassword(id: string, newPassword: string): Promise<void> {
    const hashedPassword = await this.hashPassword(newPassword);

    await query(
      `UPDATE ${this.tableName} 
       SET password = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2`,
      [hashedPassword, id]
    );

    logger.info(`Password updated for user ID: ${id}`);
  }

  /**
   * Update last login timestamp
   */
  async updateLastLogin(id: string): Promise<void> {
    await query(
      `UPDATE ${this.tableName} 
       SET last_login = CURRENT_TIMESTAMP 
       WHERE id = $1`,
      [id]
    );
  }

  /**
   * Update user avatar
   */
  async updateAvatar(id: string, avatarUrl: string): Promise<IUser> {
    const result = await query(
      `UPDATE ${this.tableName} 
       SET avatar = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2
       RETURNING *`,
      [avatarUrl, id]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    return result.rows[0];
  }

  /**
   * Activate/Deactivate user
   */
  async setActiveStatus(id: string, isActive: boolean): Promise<IUser> {
    const result = await query(
      `UPDATE ${this.tableName} 
       SET is_active = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2
       RETURNING *`,
      [isActive, id]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    const user = result.rows[0];
    logger.info(`User ${isActive ? \'activated\' : \'deactivated\'}: ${user.username} (${user.id})`);

    return user;
  }

  // ==========================================
  // DELETE
  // ==========================================

  /**
   * Delete user by ID (soft delete - deactivate)
   */
  async softDelete(id: string): Promise<void> {
    await this.setActiveStatus(id, false);
  }

  /**
   * Delete user by ID (hard delete - permanent)
   */
  async hardDelete(id: string): Promise<void> {
    const result = await query(
      `DELETE FROM ${this.tableName} WHERE id = $1 RETURNING id, username`,
      [id]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    logger.warn(`User permanently deleted: ${result.rows[0].username} (${id})`);
  }

  // ==========================================
  // AUTHENTICATION HELPERS
  // ==========================================

  /**
   * Hash password using bcrypt
   */
  async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, BCRYPT_CONFIG.ROUNDS);
  }

  /**
   * Compare password with hash
   */
  async comparePassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  /**
   * Verify user credentials
   */
  async verifyCredentials(username: string, password: string): Promise<IUser | null> {
    const user = await this.findByUsername(username);

    if (!user) {
      return null;
    }

    if (!user.is_active) {
      throw new ValidationError(\'حساب کاربری غیرفعال است\');
    }

    const isPasswordValid = await this.comparePassword(password, user.password);

    if (!isPasswordValid) {
      return null;
    }

    // Update last login
    await this.updateLastLogin(user.id);

    return user;
  }

  // ==========================================
  // UTILITY METHODS
  // ==========================================

  /**
   * Check if user exists by ID
   */
  async exists(id: string): Promise<boolean> {
    const result = await query(
      `SELECT EXISTS(SELECT 1 FROM ${this.tableName} WHERE id = $1)`,
      [id]
    );

    return result.rows[0]?.exists || false;
  }

  /**
   * Check if username is available
   */
  async isUsernameAvailable(username: string): Promise<boolean> {
    const user = await this.findByUsername(username);
    return !user;
  }

  /**
   * Check if email is available
   */
  async isEmailAvailable(email: string): Promise<boolean> {
    const user = await this.findByEmail(email);
    return !user;
  }

  /**
   * Get user without password field
   */
  async findByIdSafe(id: string): Promise<Omit<IUser, \'password\'> | null> {
    const result = await query(
      `SELECT id, username, email, full_name, role, phone, avatar, 
              is_active, last_login, created_at, updated_at 
       FROM ${this.tableName} 
       WHERE id = $1`,
      [id]
    );

    return result.rows[0] || null;
  }

  /**
   * Get all users without password field
   */
  async findAllSafe(filters?: IUserFilter): Promise<Omit<IUser, \'password\'>[]> {
    const users = await this.findAll(filters);
    return users.map((user) => this.omitPassword(user));
  }

  /**
   * Remove password from user object
   */
  omitPassword(user: IUser): Omit<IUser, \'password\'> {
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  /**
   * Get user statistics
   */
  async getStatistics(): Promise<{
    total: number;
    active: number;
    inactive: number;
    byRole: Record<UserRole, number>;
  }> {
    const [totalResult, activeResult, byRoleResult] = await Promise.all([
      query(`SELECT COUNT(*) as count FROM ${this.tableName}`),
      query(
        `SELECT COUNT(*) as count FROM ${this.tableName} WHERE is_active = true`
      ),
      this.getUsersCountByRole(),
    ]);

    const total = parseInt(totalResult.rows[0]?.count || \'0\', 10);
    const active = parseInt(activeResult.rows[0]?.count || \'0\', 10);

    return {
      total,
      active,
      inactive: total - active,
      byRole: byRoleResult,
    };
  }
}

// ==========================================
// EXPORT SINGLETON INSTANCE
// ==========================================

export default new UserModel();'

backend\src\routes\auth.routes.ts = '// ==========================================
// ZARMIND - Authentication Routes
// ==========================================

import { Router } from \'express\';
import authController from \'../controllers/authController\';
import { validators, validate } from \'../middleware/validation.middleware\';
import {
  authenticate,
  optionalAuthenticate,
  isAdmin,
  checkAccountLock,
} from \'../middleware/auth.middleware\';
import { body, param, query } from \'express-validator\';

const router = Router();

// ==========================================
// PUBLIC ROUTES (No Authentication Required)
// ==========================================

/**
 * @route   POST /api/auth/login
 * @desc    Login with username and password
 * @access  Public
 */
router.post(
  \'/login\',
  checkAccountLock(\'username\'),
  validators.login,
  validate,
  authController.login
);

/**
 * @route   POST /api/auth/login-email
 * @desc    Login with email and password
 * @access  Public
 */
router.post(
  \'/login-email\',
  checkAccountLock(\'email\'),
  [
    body(\'email\')
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\')
      .normalizeEmail(),
    body(\'password\')
      .notEmpty()
      .withMessage(\'رمز عبور الزامی است\'),
    body(\'rememberMe\')
      .optional()
      .isBoolean()
      .toBoolean(),
  ],
  validate,
  authController.loginWithEmail
);

/**
 * @route   POST /api/auth/register
 * @desc    Register new user
 * @access  Public (or can be restricted to Admin only)
 */
router.post(
  \'/register\',
  validators.register,
  validate,
  authController.register
);

/**
 * @route   POST /api/auth/refresh
 * @desc    Refresh access token using refresh token
 * @access  Public
 */
router.post(
  \'/refresh\',
  [
    body(\'refreshToken\')
      .notEmpty()
      .withMessage(\'توکن بازیابی الزامی است\'),
  ],
  validate,
  authController.refreshToken
);

/**
 * @route   POST /api/auth/validate
 * @desc    Validate access token
 * @access  Public
 */
router.post(
  \'/validate\',
  [
    body(\'token\')
      .notEmpty()
      .withMessage(\'توکن الزامی است\'),
  ],
  validate,
  authController.validateToken
);

/**
 * @route   GET /api/auth/status
 * @desc    Get authentication status
 * @access  Public (with optional authentication)
 */
router.get(
  \'/status\',
  optionalAuthenticate,
  authController.getAuthStatus
);

// ==========================================
// PASSWORD RESET ROUTES (Public)
// ==========================================

/**
 * @route   POST /api/auth/forgot-password
 * @desc    Request password reset (sends email with reset token)
 * @access  Public
 */
router.post(
  \'/forgot-password\',
  [
    body(\'email\')
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\')
      .normalizeEmail(),
  ],
  validate,
  authController.forgotPassword
);

/**
 * @route   POST /api/auth/reset-password
 * @desc    Reset password using reset token
 * @access  Public
 */
router.post(
  \'/reset-password\',
  [
    body(\'resetToken\')
      .notEmpty()
      .withMessage(\'توکن بازیابی الزامی است\'),
    body(\'newPassword\')
      .isLength({ min: 6, max: 128 })
      .withMessage(\'رمز عبور جدید باید بین 6 تا 128 کاراکتر باشد\'),
    body(\'confirmPassword\')
      .custom((value, { req }) => {
        if (value !== req.body.newPassword) {
          throw new Error(\'تکرار رمز عبور مطابقت ندارد\');
        }
        return true;
      }),
  ],
  validate,
  authController.resetPassword
);

// ==========================================
// AVAILABILITY CHECK ROUTES (Public)
// ==========================================

/**
 * @route   GET /api/auth/check-username/:username
 * @desc    Check if username is available
 * @access  Public
 */
router.get(
  \'/check-username/:username\',
  [
    param(\'username\')
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage(\'نام کاربری باید بین 3 تا 50 کاراکتر باشد\'),
  ],
  validate,
  authController.checkUsername
);

/**
 * @route   GET /api/auth/check-email/:email
 * @desc    Check if email is available
 * @access  Public
 */
router.get(
  \'/check-email/:email\',
  [
    param(\'email\')
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\'),
  ],
  validate,
  authController.checkEmail
);

/**
 * @route   POST /api/auth/check-availability
 * @desc    Check username and/or email availability
 * @access  Public
 */
router.post(
  \'/check-availability\',
  [
    body(\'username\')
      .optional()
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage(\'نام کاربری باید بین 3 تا 50 کاراکتر باشد\'),
    body(\'email\')
      .optional()
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\'),
  ],
  validate,
  authController.checkAvailability
);

// ==========================================
// PROTECTED ROUTES (Authentication Required)
// ==========================================

/**
 * @route   POST /api/auth/logout
 * @desc    Logout and blacklist token
 * @access  Private
 */
router.post(
  \'/logout\',
  authenticate,
  authController.logout
);

/**
 * @route   GET /api/auth/verify
 * @desc    Verify if user is authenticated
 * @access  Private
 */
router.get(
  \'/verify\',
  authenticate,
  authController.verifyAuthentication
);

// ==========================================
// PROFILE ROUTES (Private)
// ==========================================

/**
 * @route   GET /api/auth/me
 * @desc    Get current user profile
 * @access  Private
 */
router.get(
  \'/me\',
  authenticate,
  authController.getProfile
);

/**
 * @route   PUT /api/auth/me
 * @desc    Update current user profile
 * @access  Private
 */
router.put(
  \'/me\',
  authenticate,
  [
    body(\'full_name\')
      .optional()
      .trim()
      .isLength({ min: 2, max: 255 })
      .withMessage(\'نام کامل باید بین 2 تا 255 کاراکتر باشد\'),
    body(\'phone\')
      .optional()
      .trim()
      .isMobilePhone(\'fa-IR\')
      .withMessage(\'شماره تلفن نامعتبر است\'),
    body(\'email\')
      .optional()
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\')
      .normalizeEmail(),
    body(\'avatar\')
      .optional()
      .trim()
      .isURL()
      .withMessage(\'آدرس تصویر نامعتبر است\'),
  ],
  validate,
  authController.updateProfile
);

/**
 * @route   PUT /api/auth/avatar
 * @desc    Update user avatar
 * @access  Private
 */
router.put(
  \'/avatar\',
  authenticate,
  // File upload middleware would go here
  [
    body(\'avatar\')
      .optional()
      .trim()
      .isURL()
      .withMessage(\'آدرس تصویر نامعتبر است\'),
  ],
  validate,
  authController.updateAvatar
);

// ==========================================
// PASSWORD MANAGEMENT ROUTES (Private)
// ==========================================

/**
 * @route   PUT /api/auth/change-password
 * @desc    Change password (requires current password)
 * @access  Private
 */
router.put(
  \'/change-password\',
  authenticate,
  validators.updatePassword,
  validate,
  authController.changePassword
);

// ==========================================
// SESSION MANAGEMENT ROUTES (Private)
// ==========================================

/**
 * @route   GET /api/auth/sessions
 * @desc    Get all active sessions
 * @access  Private
 */
router.get(
  \'/sessions\',
  authenticate,
  authController.getSessions
);

/**
 * @route   DELETE /api/auth/sessions
 * @desc    Logout from all devices
 * @access  Private
 */
router.delete(
  \'/sessions\',
  authenticate,
  authController.revokeSessions
);

// ==========================================
// SECURITY ROUTES (Private)
// ==========================================

/**
 * @route   GET /api/auth/login-history
 * @desc    Get login history
 * @access  Private
 */
router.get(
  \'/login-history\',
  authenticate,
  [
    query(\'limit\')
      .optional()
      .isInt({ min: 1, max: 100 })
      .withMessage(\'حد مجاز باید بین 1 تا 100 باشد\')
      .toInt(),
  ],
  validate,
  authController.getLoginHistory
);

/**
 * @route   POST /api/auth/enable-2fa
 * @desc    Enable two-factor authentication
 * @access  Private
 */
router.post(
  \'/enable-2fa\',
  authenticate,
  authController.enableTwoFactor
);

/**
 * @route   POST /api/auth/verify-2fa
 * @desc    Verify two-factor authentication code
 * @access  Private
 */
router.post(
  \'/verify-2fa\',
  authenticate,
  [
    body(\'code\')
      .notEmpty()
      .withMessage(\'کد تایید الزامی است\')
      .isLength({ min: 6, max: 6 })
      .withMessage(\'کد تایید باید 6 رقم باشد\'),
  ],
  validate,
  authController.verifyTwoFactor
);

// ==========================================
// ADMIN ROUTES (Admin Only)
// ==========================================

/**
 * @route   PUT /api/auth/reset-password/:userId
 * @desc    Admin reset user password
 * @access  Private (Admin only)
 */
router.put(
  \'/reset-password/:userId\',
  authenticate,
  isAdmin,
  [
    param(\'userId\')
      .isUUID()
      .withMessage(\'شناسه کاربر نامعتبر است\'),
    body(\'newPassword\')
      .isLength({ min: 6, max: 128 })
      .withMessage(\'رمز عبور جدید باید بین 6 تا 128 کاراکتر باشد\'),
  ],
  validate,
  authController.adminResetPassword
);

// ==========================================
// EXPORTS
// ==========================================

export default router;'

backend\src\services\authService.ts = '// ==========================================
// ZARMIND - Authentication Service
// ==========================================

import UserModel, { ICreateUser } from \'../models/User\';
import {
  IUser,
  IAuthTokens,
  ITokenPayload,
  UnauthorizedError,
  ValidationError,
  ConflictError,
  NotFoundError,
} from \'../types\';
import {TokenExpiredError} from \'jsonwebtoken\';
import {
  generateAccessToken,
  generateRefreshToken,
  verifyRefreshToken,
  blacklistToken,
  trackFailedLogin,
  resetLoginAttempts,
  isAccountLocked,
} from \'../middleware/auth.middleware\';
import logger, { logAuth, logSecurity } from \'../utils/logger\';
import { sanitizePhoneNumber } from \'../utils/helpers\';

// ==========================================
// INTERFACES
// ==========================================

export interface ILoginCredentials {
  username: string;
  password: string;
  rememberMe?: boolean;
}

export interface IRegisterData extends ICreateUser {
  confirmPassword?: string;
}

export interface ILoginResponse {
  user: Omit<IUser, \'password\'>;
  tokens: IAuthTokens;
}

export interface IChangePasswordData {
  userId: string;
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}

export interface IResetPasswordData {
  userId: string;
  newPassword: string;
}

export interface IRefreshTokenData {
  refreshToken: string;
}

// ==========================================
// AUTHENTICATION SERVICE
// ==========================================

class AuthService {
  // ==========================================
  // LOGIN
  // ==========================================

  /**
   * Authenticate user and return tokens
   */
  async login(
    credentials: ILoginCredentials,
    ipAddress?: string,
    userAgent?: string
  ): Promise<ILoginResponse> {
    try {
      const { username, password, rememberMe } = credentials;

      // Sanitize username
      const sanitizedUsername = username.trim().toLowerCase();

      // Check if account is locked
      if (isAccountLocked(sanitizedUsername)) {
        logSecurity(\'Locked account login attempt\', \'medium\', {
          username: sanitizedUsername,
          ip: ipAddress,
        });

        throw new UnauthorizedError(
          \'حساب کاربری شما به دلیل تلاش‌های متعدد ناموفق قفل شده است. لطفاً 15 دقیقه صبر کنید\'
        );
      }

      // Verify credentials
      const user = await UserModel.verifyCredentials(sanitizedUsername, password);

      if (!user) {
        // Track failed login attempt
        trackFailedLogin(sanitizedUsername);

        logAuth(\'failed_login\', sanitizedUsername, ipAddress, userAgent);

        throw new UnauthorizedError(\'نام کاربری یا رمز عبور اشتباه است\');
      }

      // Reset failed login attempts on successful login
      resetLoginAttempts(sanitizedUsername);

      // Generate tokens
      const tokens = this.generateTokens(user, rememberMe);

      // Log successful login
      logAuth(\'login\', user.username, ipAddress, userAgent);

      logger.info(\'User logged in successfully\', {
        userId: user.id,
        username: user.username,
        role: user.role,
        ip: ipAddress,
      });

      return {
        user: UserModel.omitPassword(user),
        tokens,
      };
    } catch (error) {
      logger.error(\'Login error:\', error);
      throw error;
    }
  }

  /**
   * Login with email instead of username
   */
  async loginWithEmail(
    email: string,
    password: string,
    ipAddress?: string,
    userAgent?: string
  ): Promise<ILoginResponse> {
    try {
      const sanitizedEmail = email.trim().toLowerCase();

      // Check if account is locked
      if (isAccountLocked(sanitizedEmail)) {
        throw new UnauthorizedError(
          \'حساب کاربری شما به دلیل تلاش‌های متعدد ناموفق قفل شده است. لطفاً 15 دقیقه صبر کنید\'
        );
      }

      // Find user by email
      const user = await UserModel.findByEmail(sanitizedEmail);

      if (!user) {
        trackFailedLogin(sanitizedEmail);
        throw new UnauthorizedError(\'ایمیل یا رمز عبور اشتباه است\');
      }

      // Verify password
      const isPasswordValid = await UserModel.comparePassword(password, user.password);

      if (!isPasswordValid) {
        trackFailedLogin(sanitizedEmail);
        throw new UnauthorizedError(\'ایمیل یا رمز عبور اشتباه است\');
      }

      if (!user.is_active) {
        throw new UnauthorizedError(\'حساب کاربری غیرفعال است\');
      }

      // Reset failed attempts and update last login
      resetLoginAttempts(sanitizedEmail);
      await UserModel.updateLastLogin(user.id);

      // Generate tokens
      const tokens = this.generateTokens(user);

      logAuth(\'login\', user.username, ipAddress, userAgent);

      return {
        user: UserModel.omitPassword(user),
        tokens,
      };
    } catch (error) {
      logger.error(\'Login with email error:\', error);
      throw error;
    }
  }

  // ==========================================
  // REGISTER
  // ==========================================

  /**
   * Register new user
   */
  async register(
    registerData: IRegisterData,
    ipAddress?: string,
    userAgent?: string
  ): Promise<ILoginResponse> {
    try {
      // Validate passwords match
      if (registerData.password !== registerData.confirmPassword) {
        throw new ValidationError(\'رمز عبور و تکرار آن مطابقت ندارند\');
      }

      // Sanitize data
      const sanitizedData: ICreateUser = {
        username: registerData.username.trim().toLowerCase(),
        email: registerData.email.trim().toLowerCase(),
        password: registerData.password,
        full_name: registerData.full_name.trim(),
        role: registerData.role,
        phone: registerData.phone ? sanitizePhoneNumber(registerData.phone) : undefined,
        avatar: registerData.avatar,
        is_active: registerData.is_active !== undefined ? registerData.is_active : true,
      };

      // Validate username availability
      const usernameExists = await UserModel.findByUsername(sanitizedData.username);
      if (usernameExists) {
        throw new ConflictError(`نام کاربری "${sanitizedData.username}" قبلاً ثبت شده است`);
      }

      // Validate email availability
      const emailExists = await UserModel.findByEmail(sanitizedData.email);
      if (emailExists) {
        throw new ConflictError(`ایمیل "${sanitizedData.email}" قبلاً ثبت شده است`);
      }

      // Create user
      const user = await UserModel.create(sanitizedData);

      // Generate tokens
      const tokens = this.generateTokens(user);

      // Log registration
      logAuth(\'register\', user.username, ipAddress, userAgent);

      logger.info(\'User registered successfully\', {
        userId: user.id,
        username: user.username,
        email: user.email,
        role: user.role,
      });

      return {
        user: UserModel.omitPassword(user),
        tokens,
      };
    } catch (error) {
      logger.error(\'Registration error:\', error);
      throw error;
    }
  }

  // ==========================================
  // LOGOUT
  // ==========================================

  /**
   * Logout user and blacklist token
   */
  async logout(
    accessToken: string,
    userId?: string,
    ipAddress?: string,
    userAgent?: string
  ): Promise<void> {
    try {
      // Add token to blacklist
      if (accessToken) {
        blacklistToken(accessToken);
      }

      if (userId) {
        const user = await UserModel.findById(userId);
        if (user) {
          logAuth(\'logout\', user.username, ipAddress, userAgent);
        }

        logger.info(\'User logged out\', {
          userId,
          ip: ipAddress,
        });
      }
    } catch (error) {
      logger.error(\'Logout error:\', error);
      throw error;
    }
  }

  // ==========================================
  // TOKEN OPERATIONS
  // ==========================================

  /**
   * Generate access and refresh tokens
   */
  generateTokens(user: IUser, _rememberMe?: boolean): IAuthTokens {
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    return {
      accessToken,
      refreshToken,
    };
  }

  /**
   * Refresh access token using refresh token
   */
  async refreshAccessToken(refreshTokenData: IRefreshTokenData): Promise<IAuthTokens> {
    try {
      const { refreshToken } = refreshTokenData;

      // Verify refresh token
      const decoded = verifyRefreshToken(refreshToken);

      // Get user
      const user = await UserModel.findById(decoded.userId);

      if (!user) {
        throw new UnauthorizedError(\'کاربر یافت نشد\');
      }

      if (!user.is_active) {
        throw new UnauthorizedError(\'حساب کاربری غیرفعال است\');
      }

      // Generate new tokens
      const tokens = this.generateTokens(user);

      logger.info(\'Access token refreshed\', {
        userId: user.id,
        username: user.username,
      });

      return tokens;
    } catch (error) {
      logger.error(\'Token refresh error:\', error);
      throw error;
    }
  }

  /**
   * Validate access token
   */
  async validateToken(token: string): Promise<ITokenPayload> {
    try {
      // This would use the verifyToken from middleware
      // For now, we\'ll import jwt directly
      const jwt = require(\'jsonwebtoken\');
      const { JWT_CONFIG } = require(\'../config/server\');

      const decoded = jwt.verify(token, JWT_CONFIG.SECRET) as ITokenPayload;

      // Verify user still exists and is active
      const user = await UserModel.findById(decoded.userId);

      if (!user || !user.is_active) {
        throw new UnauthorizedError(\'توکن نامعتبر است\');
      }

      return decoded;
    } catch (error) {
      throw new UnauthorizedError(\'توکن نامعتبر یا منقضی شده است\');
    }
  }

  // ==========================================
  // PASSWORD MANAGEMENT
  // ==========================================

  /**
   * Change user password
   */
  async changePassword(passwordData: IChangePasswordData): Promise<void> {
    try {
      const { userId, currentPassword, newPassword, confirmPassword } = passwordData;

      // Validate new passwords match
      if (newPassword !== confirmPassword) {
        throw new ValidationError(\'رمز عبور جدید و تکرار آن مطابقت ندارند\');
      }

      // Validate new password is different from current
      if (currentPassword === newPassword) {
        throw new ValidationError(\'رمز عبور جدید باید با رمز عبور فعلی متفاوت باشد\');
      }

      // Get user
      const user = await UserModel.findById(userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      // Verify current password
      const isCurrentPasswordValid = await UserModel.comparePassword(
        currentPassword,
        user.password
      );

      if (!isCurrentPasswordValid) {
        throw new UnauthorizedError(\'رمز عبور فعلی اشتباه است\');
      }

      // Update password
      await UserModel.updatePassword(userId, newPassword);

      logger.info(\'Password changed successfully\', {
        userId,
        username: user.username,
      });
    } catch (error) {
      logger.error(\'Change password error:\', error);
      throw error;
    }
  }

  /**
   * Reset password (admin function - no current password required)
   */
  async resetPassword(resetData: IResetPasswordData): Promise<void> {
    try {
      const { userId, newPassword } = resetData;

      // Get user
      const user = await UserModel.findById(userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      // Update password
      await UserModel.updatePassword(userId, newPassword);

      logger.warn(\'Password reset by admin\', {
        userId,
        username: user.username,
      });
    } catch (error) {
      logger.error(\'Reset password error:\', error);
      throw error;
    }
  }

  /**
   * Request password reset (generate reset token)
   * Note: This is a placeholder - in production, you\'d send an email with reset link
   */
  async requestPasswordReset(email: string): Promise<{ message: string; resetToken?: string }> {
    try {
      const user = await UserModel.findByEmail(email.trim().toLowerCase());

      if (!user) {
        // Don\'t reveal if user exists
        return {
          message: \'اگر این ایمیل در سیستم موجود باشد، لینک بازیابی رمز عبور برای شما ارسال می‌شود\',
        };
      }

      // Generate reset token (valid for 1 hour)
      const jwt = require(\'jsonwebtoken\');
      const { JWT_CONFIG } = require(\'../config/server\');

      const resetToken = jwt.sign(
        { userId: user.id, type: \'password_reset\' },
        JWT_CONFIG.SECRET,
        { expiresIn: \'1h\' }
      );

      // In production: Send email with reset link
      // await emailService.sendPasswordResetEmail(user.email, resetToken);

      logger.info(\'Password reset requested\', {
        userId: user.id,
        email: user.email,
      });

      // In development, return token (remove in production)
      if (process.env.NODE_ENV === \'development\') {
        return {
          message: \'لینک بازیابی رمز عبور برای شما ارسال شد\',
          resetToken,
        };
      }

      return {
        message: \'لینک بازیابی رمز عبور برای شما ارسال شد\',
      };
    } catch (error) {
      logger.error(\'Request password reset error:\', error);
      throw error;
    }
  }

  /**
   * Confirm password reset with token
   */
  async confirmPasswordReset(resetToken: string, newPassword: string): Promise<void> {
    try {
      const jwt = require(\'jsonwebtoken\');
      const { JWT_CONFIG } = require(\'../config/server\');

      // Verify reset token
      const decoded = jwt.verify(resetToken, JWT_CONFIG.SECRET) as {
        userId: string;
        type: string;
      };

      if (decoded.type !== \'password_reset\') {
        throw new UnauthorizedError(\'توکن بازیابی نامعتبر است\');
      }

      // Get user
      const user = await UserModel.findById(decoded.userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      // Update password
      await UserModel.updatePassword(decoded.userId, newPassword);

      logger.info(\'Password reset confirmed\', {
        userId: user.id,
        username: user.username,
      });
    } catch (error) {
      if (error instanceof TokenExpiredError) {
        throw new UnauthorizedError(\'لینک بازیابی منقضی شده است. لطفاً دوباره درخواست دهید\');
      }
      logger.error(\'Confirm password reset error:\', error);
      throw error;
    }
  }

  // ==========================================
  // USER PROFILE
  // ==========================================

  /**
   * Get current user profile
   */
  async getProfile(userId: string): Promise<Omit<IUser, \'password\'>> {
    try {
      const user = await UserModel.findByIdSafe(userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      return user;
    } catch (error) {
      logger.error(\'Get profile error:\', error);
      throw error;
    }
  }

  /**
   * Update user profile
   */
  async updateProfile(
    userId: string,
    updateData: {
      full_name?: string;
      phone?: string;
      email?: string;
      avatar?: string;
    }
  ): Promise<Omit<IUser, \'password\'>> {
    try {
      // Sanitize phone if provided
      if (updateData.phone) {
        updateData.phone = sanitizePhoneNumber(updateData.phone);
      }

      // Sanitize email if provided
      if (updateData.email) {
        updateData.email = updateData.email.trim().toLowerCase();
      }

      const updatedUser = await UserModel.update(userId, updateData);

      logger.info(\'Profile updated\', {
        userId,
        username: updatedUser.username,
      });

      return UserModel.omitPassword(updatedUser);
    } catch (error) {
      logger.error(\'Update profile error:\', error);
      throw error;
    }
  }

  // ==========================================
  // ACCOUNT VERIFICATION
  // ==========================================

  /**
   * Check if username is available
   */
  async checkUsernameAvailability(username: string): Promise<boolean> {
    const sanitizedUsername = username.trim().toLowerCase();
    return await UserModel.isUsernameAvailable(sanitizedUsername);
  }

  /**
   * Check if email is available
   */
  async checkEmailAvailability(email: string): Promise<boolean> {
    const sanitizedEmail = email.trim().toLowerCase();
    return await UserModel.isEmailAvailable(sanitizedEmail);
  }

  /**
   * Verify user exists and is active
   */
  async verifyUserActive(userId: string): Promise<boolean> {
    const user = await UserModel.findById(userId);
    return user !== null && user.is_active;
  }

  // ==========================================
  // SESSION MANAGEMENT
  // ==========================================

  /**
   * Get all active sessions for user (placeholder)
   * In production, track sessions in Redis
   */
  async getActiveSessions(_userId: string): Promise<any[]> {
    // This would query Redis or session store
    // For now, return empty array
    return [];
  }

  /**
   * Revoke all sessions for user (force logout everywhere)
   */
  async revokeAllSessions(userId: string): Promise<void> {
    try {
      // In production, clear all sessions from Redis
      // and blacklist all active tokens

      logger.warn(\'All sessions revoked for user\', { userId });
    } catch (error) {
      logger.error(\'Revoke sessions error:\', error);
      throw error;
    }
  }

  // ==========================================
  // SECURITY
  // ==========================================

  /**
   * Get user\'s recent login history (placeholder)
   */
  async getLoginHistory(_userId: string, _limit: number = 10): Promise<any[]> {
    // This would query audit logs
    // For now, return empty array
    return [];
  }

  /**
   * Enable two-factor authentication (placeholder)
   */
  async enableTwoFactor(_userId: string): Promise<{ secret: string; qrCode: string }> {
    // This would setup 2FA with libraries like speakeasy
    throw new Error(\'Two-factor authentication not implemented yet\');
  }

  /**
   * Verify two-factor code (placeholder)
   */
  async verifyTwoFactor(_userId: string, _code: string): Promise<boolean> {
    // This would verify 2FA code
    throw new Error(\'Two-factor authentication not implemented yet\');
  }
}

// ==========================================
// EXPORT SINGLETON INSTANCE
// ==========================================

export default new AuthService();'

node_modules\zarmind-backend\src\controllers\authController.ts = '// ==========================================
// ZARMIND - Authentication Controller
// ==========================================

import { Request, Response } from \'express\';
import { asyncHandler } from \'../middleware/error.middleware\';
import AuthService from \'../services/authService\';
import { getCurrentUserId, getCurrentUser, AuthenticatedRequest } from \'../middleware/auth.middleware\';
import { UnauthorizedError, ValidationError } from \'../types\';
import { COOKIE_CONFIG } from \'../config/server\';

// ==========================================
// HELPER FUNCTIONS
// ==========================================

/**
 * Set authentication cookies
 */
const setAuthCookies = (res: Response, accessToken: string, refreshToken: string): void => {
  // Access token cookie (short-lived)
  res.cookie(\'accessToken\', accessToken, {
    ...COOKIE_CONFIG.OPTIONS,
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });

  // Refresh token cookie (long-lived)
  res.cookie(\'refreshToken\', refreshToken, {
    ...COOKIE_CONFIG.OPTIONS,
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
  });
};

/**
 * Clear authentication cookies
 */
const clearAuthCookies = (res: Response): void => {
  res.clearCookie(\'accessToken\');
  res.clearCookie(\'refreshToken\');
};

/**
 * Extract access token from request
 */
const extractAccessToken = (req: Request): string | null => {
  // Try header first
  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith(\'Bearer \')) {
    const token = authHeader.split(\' \')[1];
    return token || null;
  }

  // Try cookie
  return req.cookies?.accessToken || req.signedCookies?.accessToken || null;
};

// ==========================================
// AUTHENTICATION CONTROLLERS
// ==========================================

/**
 * @route   POST /api/auth/login
 * @desc    Login user with username/password
 * @access  Public
 */
export const login = asyncHandler(async (req: Request, res: Response) => {
  const { username, password, rememberMe } = req.body;

  // Validate input
  if (!username || !password) {
    throw new ValidationError(\'نام کاربری و رمز عبور الزامی است\');
  }

  // Login user
  const result = await AuthService.login(
    { username, password, rememberMe },
    req.ip,
    req.get(\'user-agent\')
  );

  // Set cookies
  setAuthCookies(res, result.tokens.accessToken, result.tokens.refreshToken);

  // Send response
  res.sendSuccess(
    {
      user: result.user,
      accessToken: result.tokens.accessToken,
      refreshToken: result.tokens.refreshToken,
    },
    \'ورود موفقیت‌آمیز بود\'
  );
});

/**
 * @route   POST /api/auth/login-email
 * @desc    Login user with email/password
 * @access  Public
 */
export const loginWithEmail = asyncHandler(async (req: Request, res: Response) => {
  const { email, password } = req.body;

  // Validate input
  if (!email || !password) {
    throw new ValidationError(\'ایمیل و رمز عبور الزامی است\');
  }

  // Login user
  const result = await AuthService.loginWithEmail(
    email,
    password,
    req.ip,
    req.get(\'user-agent\')
  );

  // Set cookies
  setAuthCookies(res, result.tokens.accessToken, result.tokens.refreshToken);

  // Send response
  res.sendSuccess(
    {
      user: result.user,
      accessToken: result.tokens.accessToken,
      refreshToken: result.tokens.refreshToken,
    },
    \'ورود موفقیت‌آمیز بود\'
  );
});

/**
 * @route   POST /api/auth/register
 * @desc    Register new user
 * @access  Public (or Admin only for creating users)
 */
export const register = asyncHandler(async (req: Request, res: Response) => {
  const registerData = req.body;

  // Register user
  const result = await AuthService.register(
    registerData,
    req.ip,
    req.get(\'user-agent\')
  );

  // Set cookies
  setAuthCookies(res, result.tokens.accessToken, result.tokens.refreshToken);

  // Send response
  res.status(201).json({
    success: true,
    message: \'ثبت‌نام با موفقیت انجام شد\',
    data: {
      user: result.user,
      accessToken: result.tokens.accessToken,
      refreshToken: result.tokens.refreshToken,
    },
  });
});

/**
 * @route   POST /api/auth/logout
 * @desc    Logout user and blacklist token
 * @access  Private
 */
export const logout = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);
  const accessToken = extractAccessToken(req);

  if (accessToken) {
    await AuthService.logout(accessToken, userId, req.ip, req.get(\'user-agent\'));
  }

  // Clear cookies
  clearAuthCookies(res);

  res.sendSuccess(null, \'خروج با موفقیت انجام شد\');
});

/**
 * @route   POST /api/auth/refresh
 * @desc    Refresh access token using refresh token
 * @access  Public
 */
export const refreshToken = asyncHandler(async (req: Request, res: Response) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    throw new ValidationError(\'توکن بازیابی الزامی است\');
  }

  // Refresh tokens
  const tokens = await AuthService.refreshAccessToken({ refreshToken });

  // Set new cookies
  setAuthCookies(res, tokens.accessToken, tokens.refreshToken);

  res.sendSuccess(
    {
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
    },
    \'توکن با موفقیت بازیابی شد\'
  );
});

/**
 * @route   POST /api/auth/validate
 * @desc    Validate access token
 * @access  Public
 */
export const validateToken = asyncHandler(async (req: Request, res: Response) => {
  const { token } = req.body;

  if (!token) {
    throw new ValidationError(\'توکن الزامی است\');
  }

  const payload = await AuthService.validateToken(token);

  res.sendSuccess(
    {
      valid: true,
      payload,
    },
    \'توکن معتبر است\'
  );
});

// ==========================================
// PROFILE CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/me
 * @desc    Get current user profile
 * @access  Private
 */
export const getProfile = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const profile = await AuthService.getProfile(userId);

  res.sendSuccess(profile, \'اطلاعات پروفایل دریافت شد\');
});

/**
 * @route   PUT /api/auth/me
 * @desc    Update current user profile
 * @access  Private
 */
export const updateProfile = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const { full_name, phone, email, avatar } = req.body;

  const updatedProfile = await AuthService.updateProfile(userId, {
    full_name,
    phone,
    email,
    avatar,
  });

  res.sendSuccess(updatedProfile, \'پروفایل با موفقیت به‌روزرسانی شد\');
});

/**
 * @route   PUT /api/auth/avatar
 * @desc    Update user avatar
 * @access  Private
 */
export const updateAvatar = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  // Avatar URL should come from file upload middleware
  const avatarUrl = req.body.avatar || req.file?.path;

  if (!avatarUrl) {
    throw new ValidationError(\'فایل تصویر الزامی است\');
  }

  const updatedProfile = await AuthService.updateProfile(userId, {
    avatar: avatarUrl,
  });

  res.sendSuccess(updatedProfile, \'تصویر پروفایل با موفقیت به‌روزرسانی شد\');
});

// ==========================================
// PASSWORD CONTROLLERS
// ==========================================

/**
 * @route   PUT /api/auth/change-password
 * @desc    Change user password (requires current password)
 * @access  Private
 */
export const changePassword = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const { currentPassword, newPassword, confirmPassword } = req.body;

  // Validate input
  if (!currentPassword || !newPassword || !confirmPassword) {
    throw new ValidationError(\'تمام فیلدها الزامی هستند\');
  }

  await AuthService.changePassword({
    userId,
    currentPassword,
    newPassword,
    confirmPassword,
  });

  res.sendSuccess(null, \'رمز عبور با موفقیت تغییر کرد\');
});

/**
 * @route   POST /api/auth/forgot-password
 * @desc    Request password reset (send reset email)
 * @access  Public
 */
export const forgotPassword = asyncHandler(async (req: Request, res: Response) => {
  const { email } = req.body;

  if (!email) {
    throw new ValidationError(\'ایمیل الزامی است\');
  }

  const result = await AuthService.requestPasswordReset(email);

  // In production, only send message (hide resetToken)
  if (process.env.NODE_ENV === \'development\') {
    res.sendSuccess(result, result.message);
  } else {
    res.sendSuccess({ message: result.message }, result.message);
  }
});

/**
 * @route   POST /api/auth/reset-password
 * @desc    Reset password with reset token
 * @access  Public
 */
export const resetPassword = asyncHandler(async (req: Request, res: Response) => {
  const { resetToken, newPassword, confirmPassword } = req.body;

  if (!resetToken || !newPassword || !confirmPassword) {
    throw new ValidationError(\'تمام فیلدها الزامی هستند\');
  }

  if (newPassword !== confirmPassword) {
    throw new ValidationError(\'رمز عبور جدید و تکرار آن مطابقت ندارند\');
  }

  await AuthService.confirmPasswordReset(resetToken, newPassword);

  res.sendSuccess(null, \'رمز عبور با موفقیت بازیابی شد\');
});

/**
 * @route   PUT /api/auth/reset-password/:userId
 * @desc    Admin reset user password (no current password required)
 * @access  Private (Admin only)
 */
export const adminResetPassword = asyncHandler(async (req: Request, res: Response) => {
  const { userId } = req.params;
  const { newPassword } = req.body;

  // Validate userId exists
  if (!userId) {
    throw new ValidationError(\'شناسه کاربر الزامی است\');
  }

  if (!newPassword) {
    throw new ValidationError(\'رمز عبور جدید الزامی است\');
  }

  await AuthService.resetPassword({ userId, newPassword });

  res.sendSuccess(null, \'رمز عبور کاربر با موفقیت بازنشانی شد\');
});
// ==========================================
// ACCOUNT VERIFICATION CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/check-username/:username
 * @desc    Check if username is available
 * @access  Public
 */
export const checkUsername = asyncHandler(async (req: Request, res: Response) => {
  const { username } = req.params;

  if (!username) {
    throw new ValidationError(\'نام کاربری الزامی است\');
  }

  const isAvailable = await AuthService.checkUsernameAvailability(username);

  res.sendSuccess(
    {
      username,
      available: isAvailable,
    },
    isAvailable ? \'نام کاربری در دسترس است\' : \'نام کاربری قبلاً ثبت شده است\'
  );
});

/**
 * @route   GET /api/auth/check-email/:email
 * @desc    Check if email is available
 * @access  Public
 */
export const checkEmail = asyncHandler(async (req: Request, res: Response) => {
  const { email } = req.params;

  if (!email) {
    throw new ValidationError(\'ایمیل الزامی است\');
  }

  const isAvailable = await AuthService.checkEmailAvailability(email);

  res.sendSuccess(
    {
      email,
      available: isAvailable,
    },
    isAvailable ? \'ایمیل در دسترس است\' : \'ایمیل قبلاً ثبت شده است\'
  );
});

/**
 * @route   POST /api/auth/check-availability
 * @desc    Check username and email availability
 * @access  Public
 */
export const checkAvailability = asyncHandler(async (req: Request, res: Response) => {
  const { username, email } = req.body;

  const result: {
    username?: { value: string; available: boolean };
    email?: { value: string; available: boolean };
  } = {};

  if (username) {
    const usernameAvailable = await AuthService.checkUsernameAvailability(username);
    result.username = {
      value: username,
      available: usernameAvailable,
    };
  }

  if (email) {
    const emailAvailable = await AuthService.checkEmailAvailability(email);
    result.email = {
      value: email,
      available: emailAvailable,
    };
  }

  res.sendSuccess(result, \'بررسی در دسترس بودن انجام شد\');
});

// ==========================================
// SESSION MANAGEMENT CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/sessions
 * @desc    Get all active sessions for current user
 * @access  Private
 */
export const getSessions = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const sessions = await AuthService.getActiveSessions(userId);

  res.sendSuccess(sessions, \'لیست نشست‌های فعال دریافت شد\');
});

/**
 * @route   DELETE /api/auth/sessions
 * @desc    Revoke all sessions (logout from all devices)
 * @access  Private
 */
export const revokeSessions = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  await AuthService.revokeAllSessions(userId);

  // Clear current session cookies
  clearAuthCookies(res);

  res.sendSuccess(null, \'تمام نشست‌ها با موفقیت لغو شدند\');
});

// ==========================================
// SECURITY CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/login-history
 * @desc    Get user\'s recent login history
 * @access  Private
 */
export const getLoginHistory = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  const limit = parseInt(req.query.limit as string) || 10;
  const history = await AuthService.getLoginHistory(userId, limit);

  res.sendSuccess(history, \'تاریخچه ورود دریافت شد\');
});

/**
 * @route   POST /api/auth/enable-2fa
 * @desc    Enable two-factor authentication
 * @access  Private
 */
export const enableTwoFactor = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  try {
    const result = await AuthService.enableTwoFactor(userId);
    res.sendSuccess(result, \'احراز هویت دو مرحله‌ای فعال شد\');
  } catch (error) {
    res.sendSuccess(
      null,
      \'احراز هویت دو مرحله‌ای هنوز پیاده‌سازی نشده است\'
    );
  }
});

/**
 * @route   POST /api/auth/verify-2fa
 * @desc    Verify two-factor authentication code
 * @access  Private
 */
export const verifyTwoFactor = asyncHandler(async (req: Request, res: Response) => {
  const userId = getCurrentUserId(req);
  const { code } = req.body;

  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  if (!code) {
    throw new ValidationError(\'کد تایید الزامی است\');
  }

  try {
    const isValid = await AuthService.verifyTwoFactor(userId, code);
    res.sendSuccess({ valid: isValid }, \'کد تایید معتبر است\');
  } catch (error) {
    res.sendSuccess(
      null,
      \'احراز هویت دو مرحله‌ای هنوز پیاده‌سازی نشده است\'
    );
  }
});

// ==========================================
// UTILITY CONTROLLERS
// ==========================================

/**
 * @route   GET /api/auth/verify
 * @desc    Verify if user is authenticated
 * @access  Private
 */
export const verifyAuthentication = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const user = getCurrentUser(req);

  if (!user) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }

  res.sendSuccess(
    {
      authenticated: true,
      user,
    },
    \'کاربر احراز هویت شده است\'
  );
});

/**
 * @route   GET /api/auth/status
 * @desc    Get authentication status and user info
 * @access  Public (with optional auth)
 */
export const getAuthStatus = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const user = getCurrentUser(req);

  res.sendSuccess({
    authenticated: !!user,
    user: user || null,
  });
});

// ==========================================
// EXPORTS
// ==========================================

export default {
  // Authentication
  login,
  loginWithEmail,
  register,
  logout,
  refreshToken,
  validateToken,

  // Profile
  getProfile,
  updateProfile,
  updateAvatar,

  // Password
  changePassword,
  forgotPassword,
  resetPassword,
  adminResetPassword,

  // Verification
  checkUsername,
  checkEmail,
  checkAvailability,

  // Sessions
  getSessions,
  revokeSessions,

  // Security
  getLoginHistory,
  enableTwoFactor,
  verifyTwoFactor,

  // Utility
  verifyAuthentication,
  getAuthStatus,
};'

node_modules\zarmind-backend\src\middleware\auth.middleware.ts = '// ==========================================
// ZARMIND - Authentication Middleware
// ==========================================

import { Request, Response, NextFunction } from \'express\';
import jwt from \'jsonwebtoken\';
import { JWT_CONFIG } from \'../config/server\';
import {
  ITokenPayload,
  UserRole,
  UnauthorizedError,
  ForbiddenError,
  IUser,
} from \'../types\';
import UserModel from \'../models/User\';
import logger, { logSecurity } from \'../utils/logger\';

// ==========================================
// INTERFACES
// ==========================================

export interface AuthenticatedRequest extends Request {
  user?: ITokenPayload;
  currentUser?: Omit<IUser, \'password\'>;
}

// ==========================================
// TOKEN EXTRACTION
// ==========================================

/**
 * Extract token from Authorization header
 */
const extractTokenFromHeader = (req: Request): string | null => {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return null;
  }

  // Check for "Bearer TOKEN" format
  const parts = authHeader.split(\' \');

  if (parts.length !== 2 || parts[0] !== \'Bearer\') {
    return null;
  }

  return parts[1] ?? null;
};

/**
 * Extract token from cookies
 */
const extractTokenFromCookie = (req: Request): string | null => {
  return req.cookies?.token || req.signedCookies?.token || null;
};

/**
 * Extract token from request (header or cookie)
 */
const extractToken = (req: Request): string | null => {
  // Try header first
  let token = extractTokenFromHeader(req);

  // Fallback to cookie
  if (!token) {
    token = extractTokenFromCookie(req);
  }

  return token;
};

// ==========================================
// TOKEN VERIFICATION
// ==========================================

/**
 * Verify JWT token
 */
const verifyToken = (token: string): ITokenPayload => {
  try {
    const decoded = jwt.verify(token, JWT_CONFIG.SECRET) as ITokenPayload;

    // Validate required fields
    if (!decoded.userId || !decoded.username || !decoded.role) {
      throw new UnauthorizedError(\'توکن نامعتبر است\');
    }

    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new UnauthorizedError(\'توکن منقضی شده است. لطفاً دوباره وارد شوید\');
    }

    if (error instanceof jwt.JsonWebTokenError) {
      throw new UnauthorizedError(\'توکن نامعتبر است\');
    }

    throw error;
  }
};

/**
 * Generate access token
 */
export const generateAccessToken = (user: IUser): string => {
  const payload: ITokenPayload = {
    userId: user.id,
    username: user.username,
    role: user.role,
  };

  return jwt.sign(payload, JWT_CONFIG.SECRET, {
    expiresIn: JWT_CONFIG.EXPIRE,
    issuer: JWT_CONFIG.ISSUER,
    audience: JWT_CONFIG.AUDIENCE,
  } as jwt.SignOptions);
};

/**
 * Generate refresh token
 */
export const generateRefreshToken = (user: IUser): string => {
  const payload: ITokenPayload = {
    userId: user.id,
    username: user.username,
    role: user.role,
  };

  return jwt.sign(payload, JWT_CONFIG.REFRESH_SECRET, {
    expiresIn: JWT_CONFIG.REFRESH_EXPIRE,
    issuer: JWT_CONFIG.ISSUER,
    audience: JWT_CONFIG.AUDIENCE,
  } as jwt.SignOptions);
};

/**
 * Verify refresh token
 */
export const verifyRefreshToken = (token: string): ITokenPayload => {
  try {
    const decoded = jwt.verify(token, JWT_CONFIG.REFRESH_SECRET) as ITokenPayload;

    if (!decoded.userId || !decoded.username || !decoded.role) {
      throw new UnauthorizedError(\'توکن بازیابی نامعتبر است\');
    }

    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new UnauthorizedError(\'توکن بازیابی منقضی شده است. لطفاً دوباره وارد شوید\');
    }

    throw new UnauthorizedError(\'توکن بازیابی نامعتبر است\');
  }
};

/**
 * Decode token without verification (for debugging)
 */
export const decodeToken = (token: string): ITokenPayload | null => {
  try {
    return jwt.decode(token) as ITokenPayload;
  } catch {
    return null;
  }
};

// ==========================================
// AUTHENTICATION MIDDLEWARE
// ==========================================

/**
 * Authenticate user - verify token and attach user to request
 * FIXED: Proper return statements to prevent double response
 */
export const authenticate = async (
  req: Request,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Extract token
    const token = extractToken(req);

    if (!token) {
      return next(new UnauthorizedError(\'توکن احراز هویت یافت نشد\'));
    }

    // Verify token
    const decoded = verifyToken(token);

    // Check if user still exists and is active
    const user = await UserModel.findById(decoded.userId);

    if (!user) {
      return next(new UnauthorizedError(\'کاربر یافت نشد\'));
    }

    if (!user.is_active) {
      logSecurity(\'Inactive user attempted access\', \'medium\', {
        userId: user.id,
        username: user.username,
        ip: req.ip,
      });
      return next(new UnauthorizedError(\'حساب کاربری غیرفعال است\'));
    }

    // Attach user info to request
    req.user = decoded;
    (req as AuthenticatedRequest).currentUser = UserModel.omitPassword(user);

    logger.debug(\'User authenticated\', {
      userId: decoded.userId,
      username: decoded.username,
      role: decoded.role,
      path: req.path,
    });

    next();
  } catch (error) {
    // Log failed authentication attempt
    logSecurity(\'Failed authentication attempt\', \'low\', {
      ip: req.ip,
      path: req.path,
      userAgent: req.get(\'user-agent\'),
      error: (error as Error).message,
    });

    next(error);
  }
};

/**
 * Optional authentication - attach user if token exists, but don\'t require it
 */
export const optionalAuthenticate = async (
  req: Request,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const token = extractToken(req);

    if (token) {
      const decoded = verifyToken(token);
      const user = await UserModel.findById(decoded.userId);

      if (user && user.is_active) {
        req.user = decoded;
        (req as AuthenticatedRequest).currentUser = UserModel.omitPassword(user);
      }
    }

    next();
  } catch (error) {
    // Silently fail for optional auth
    next();
  }
};

// ==========================================
// AUTHORIZATION MIDDLEWARE
// ==========================================

/**
 * Authorize user based on roles
 * FIXED: Proper return statements
 */
export const authorize = (...allowedRoles: UserRole[]) => {
  return (req: Request, _res: Response, next: NextFunction): void => {
    try {
      if (!req.user) {
        return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
      }

      const userRole = req.user.role;

      if (!allowedRoles.includes(userRole as UserRole)) {
        logSecurity(\'Unauthorized access attempt\', \'medium\', {
          userId: req.user.userId,
          username: req.user.username,
          role: userRole,
          requiredRoles: allowedRoles,
          path: req.path,
          ip: req.ip,
        });

        return next(new ForbiddenError(\'شما دسترسی به این بخش را ندارید\'));
      }

      logger.debug(\'User authorized\', {
        userId: req.user.userId,
        role: userRole,
        allowedRoles,
        path: req.path,
      });

      next();
    } catch (error) {
      next(error);
    }
  };
};

/**
 * Check if user is admin
 */
export const isAdmin = authorize(UserRole.ADMIN);

/**
 * Check if user is admin or manager
 */
export const isAdminOrManager = authorize(UserRole.ADMIN, UserRole.MANAGER);

/**
 * Check if user is admin, manager, or employee
 */
export const isEmployee = authorize(UserRole.ADMIN, UserRole.MANAGER, UserRole.EMPLOYEE);

/**
 * Allow all authenticated users (any role)
 */
export const isAuthenticated = authenticate;

// ==========================================
// OWNERSHIP MIDDLEWARE
// ==========================================

/**
 * Check if user owns the resource (by user ID in params)
 */
export const isOwner = (req: Request, _res: Response, next: NextFunction): void => {
  try {
    if (!req.user) {
      return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
    }

    const resourceUserId = req.params.userId || req.params.id;
    const currentUserId = req.user.userId;

    // Admin can access all resources
    if (req.user.role === UserRole.ADMIN) {
      return next();
    }

    // Check ownership
    if (resourceUserId !== currentUserId) {
      logSecurity(\'Ownership check failed\', \'medium\', {
        userId: currentUserId,
        requestedResourceUserId: resourceUserId,
        path: req.path,
        ip: req.ip,
      });

      return next(new ForbiddenError(\'شما فقط می‌توانید به اطلاعات خود دسترسی داشته باشید\'));
    }

    next();
  } catch (error) {
    next(error);
  }
};

/**
 * Check if user owns resource or has admin/manager role
 */
export const isOwnerOrManager = (req: Request, _res: Response, next: NextFunction): void => {
  try {
    if (!req.user) {
      return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
    }

    const resourceUserId = req.params.userId || req.params.id;
    const currentUserId = req.user.userId;
    const userRole = req.user.role as UserRole;

    // Admin or manager can access all resources
    if (userRole === UserRole.ADMIN || userRole === UserRole.MANAGER) {
      return next();
    }

    // Check ownership
    if (resourceUserId !== currentUserId) {
      return next(new ForbiddenError(\'شما دسترسی به این منبع را ندارید\'));
    }

    next();
  } catch (error) {
    next(error);
  }
};

// ==========================================
// CUSTOM AUTHORIZATION HELPERS
// ==========================================

/**
 * Check if user has specific permission
 */
export const hasPermission = (permission: string) => {
  return (req: Request, _res: Response, next: NextFunction): void => {
    try {
      if (!req.user) {
        return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
      }

      // Define permissions by role
      const rolePermissions: Record<UserRole, string[]> = {
        [UserRole.ADMIN]: [\'*\'], // All permissions
        [UserRole.MANAGER]: [
          \'users:read\',
          \'users:create\',
          \'users:update\',
          \'products:*\',
          \'customers:*\',
          \'sales:*\',
          \'reports:*\',
        ],
        [UserRole.EMPLOYEE]: [
          \'users:read:self\',
          \'products:read\',
          \'products:update\',
          \'customers:*\',
          \'sales:*\',
        ],
        [UserRole.VIEWER]: [
          \'users:read:self\',
          \'products:read\',
          \'customers:read\',
          \'sales:read\',
          \'reports:read\',
        ],
      };

      const userRole = req.user.role as UserRole;
      const permissions = rolePermissions[userRole] || [];

      // Check if user has permission
      const hasAccess =
        permissions.includes(\'*\') ||
        permissions.includes(permission) ||
        permissions.some((p) => {
          const [resource, action] = p.split(\':\');
          const [reqResource, reqAction] = permission.split(\':\');
          return resource === reqResource && (action === \'*\' || action === reqAction);
        });

      if (!hasAccess) {
        return next(new ForbiddenError(\'شما دسترسی به این عملیات را ندارید\'));
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};

/**
 * Check if user can modify resource based on creator
 */
export const canModify = (_createdByField: string = \'created_by\') => {
  return async (req: Request, _res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        return next(new UnauthorizedError(\'احراز هویت انجام نشده است\'));
      }

      const userRole = req.user.role as UserRole;

      // Admin can modify anything
      if (userRole === UserRole.ADMIN) {
        return next();
      }

      // For other roles, check if they created the resource
      // This should be implemented based on your resource logic
      // For now, managers can modify anything, others only their own
      if (userRole === UserRole.MANAGER) {
        return next();
      }

      // Employees can only modify their own resources
      // You would typically fetch the resource and check created_by
      // Example: const resource = await Model.findById(req.params.id);
      // if (resource[createdByField] !== currentUserId) { throw error }

      next();
    } catch (error) {
      next(error);
    }
  };
};

// ==========================================
// TOKEN BLACKLIST (Optional - for logout)
// ==========================================

// In-memory blacklist (in production, use Redis)
const tokenBlacklist = new Set<string>();

/**
 * Add token to blacklist
 */
export const blacklistToken = (token: string): void => {
  tokenBlacklist.add(token);
  logger.info(\'Token blacklisted\', { token: token.substring(0, 20) + \'...\' });
};

/**
 * Check if token is blacklisted
 */
export const isTokenBlacklisted = (token: string): boolean => {
  return tokenBlacklist.has(token);
};

/**
 * Middleware to check token blacklist
 */
export const checkBlacklist = (req: Request, _res: Response, next: NextFunction): void => {
  try {
    const token = extractToken(req);

    if (token && isTokenBlacklisted(token)) {
      return next(new UnauthorizedError(\'توکن نامعتبر است\'));
    }

    next();
  } catch (error) {
    next(error);
  }
};

// ==========================================
// LOGIN ATTEMPT TRACKING (Rate Limiting)
// ==========================================

// Track failed login attempts (in production, use Redis)
const loginAttempts = new Map<string, { count: number; lastAttempt: Date }>();

/**
 * Track failed login attempt
 */
export const trackFailedLogin = (identifier: string): void => {
  const attempts = loginAttempts.get(identifier) || { count: 0, lastAttempt: new Date() };
  attempts.count += 1;
  attempts.lastAttempt = new Date();
  loginAttempts.set(identifier, attempts);

  logSecurity(\'Failed login attempt\', \'low\', {
    identifier,
    attempts: attempts.count,
  });
};

/**
 * Reset login attempts on successful login
 */
export const resetLoginAttempts = (identifier: string): void => {
  loginAttempts.delete(identifier);
};

/**
 * Check if account is locked due to too many failed attempts
 */
export const isAccountLocked = (identifier: string): boolean => {
  const attempts = loginAttempts.get(identifier);

  if (!attempts) {
    return false;
  }

  // Lock after 5 failed attempts
  if (attempts.count >= 5) {
    // Check if lock period (15 minutes) has passed
    const lockDuration = 15 * 60 * 1000; // 15 minutes
    const timeSinceLastAttempt = Date.now() - attempts.lastAttempt.getTime();

    if (timeSinceLastAttempt < lockDuration) {
      return true;
    } else {
      // Lock period expired, reset attempts
      loginAttempts.delete(identifier);
      return false;
    }
  }

  return false;
};

/**
 * Middleware to check account lock status
 */
export const checkAccountLock = (identifierField: string = \'username\') => {
  return (req: Request, _res: Response, next: NextFunction): void => {
    try {
      const identifier = req.body[identifierField];

      if (identifier && isAccountLocked(identifier)) {
        logSecurity(\'Locked account access attempt\', \'high\', {
          identifier,
          ip: req.ip,
        });

        return next(new UnauthorizedError(
          \'حساب کاربری به دلیل تلاش‌های متعدد ناموفق قفل شده است. لطفاً 15 دقیقه صبر کنید\'
        ));
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};

// ==========================================
// MIDDLEWARE COMBINATIONS
// ==========================================

/**
 * Protect route - require authentication
 */
export const protect = authenticate;

/**
 * Protect route with role-based access
 */
export const protectWithRole = (...roles: UserRole[]) => {
  return [authenticate, authorize(...roles)];
};

/**
 * Protect route and check ownership
 */
export const protectOwn = [authenticate, isOwner];

/**
 * Protect route and check ownership or manager role
 */
export const protectOwnOrManager = [authenticate, isOwnerOrManager];

// ==========================================
// UTILITY FUNCTIONS
// ==========================================

/**
 * Get current user from request
 */
export const getCurrentUser = (req: AuthenticatedRequest): ITokenPayload | undefined => {
  return req.user;
};

/**
 * Require and return user ID (throw if not authenticated)
 */
export const requireUserId = (req: Request): string => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new UnauthorizedError(\'کاربر احراز هویت نشده است\');
  }
  return userId;
};

/**
 * Get current user ID from request
 */
export const getCurrentUserId = (req: Request): string | undefined => {
  return req.user?.userId;
};

/**
 * Get current user role from request
 */
export const getCurrentUserRole = (req: Request): UserRole | undefined => {
  return req.user?.role as UserRole;
};

/**
 * Check if current user is admin
 */
export const isCurrentUserAdmin = (req: Request): boolean => {
  return req.user?.role === UserRole.ADMIN;
};

/**
 * Check if current user is manager or admin
 */
export const isCurrentUserManagerOrAdmin = (req: Request): boolean => {
  const role = req.user?.role as UserRole;
  return role === UserRole.ADMIN || role === UserRole.MANAGER;
};

// ==========================================
// EXPORTS
// ==========================================

export default {
  // Main middleware
  authenticate,
  optionalAuthenticate,
  authorize,
  
  // Role-based
  isAdmin,
  isAdminOrManager,
  isEmployee,
  isAuthenticated,
  
  // Ownership
  isOwner,
  isOwnerOrManager,
  
  // Custom
  hasPermission,
  canModify,
  
  // Blacklist
  checkBlacklist,
  blacklistToken,
  isTokenBlacklisted,
  
  // Login attempts
  checkAccountLock,
  trackFailedLogin,
  resetLoginAttempts,
  isAccountLocked,
  
  // Combinations
  protect,
  protectWithRole,
  protectOwn,
  protectOwnOrManager,
  
  // Token operations
  generateAccessToken,
  generateRefreshToken,
  verifyRefreshToken,
  decodeToken,
  
  // Utilities
  getCurrentUser,
  getCurrentUserId,
  getCurrentUserRole,
  requireUserId,
  isCurrentUserAdmin,
  isCurrentUserManagerOrAdmin,
};'

node_modules\zarmind-backend\src\middleware\error.middleware.ts = '// ==========================================
// ZARMIND - Error Handling Middleware
// ==========================================

import { Request, Response, NextFunction } from \'express\';
import { MulterError } from \'multer\';
import { JsonWebTokenError, TokenExpiredError } from \'jsonwebtoken\';
import { StatusCodes } from \'http-status-codes\';
import {
  AppError,
  ValidationError,
  UnauthorizedError,
  NotFoundError,
  ConflictError,
  IValidationError,
  IApiResponse,
} from \'../types\';
import logger, { logError } from \'../utils/logger\';
import { IS_PRODUCTION } from \'../config/server\';

// ==========================================
// ERROR MESSAGES (Persian & English)
// ==========================================

const ERROR_MESSAGES = {
  INTERNAL_SERVER_ERROR: {
    fa: \'خطای داخلی سرور\',
    en: \'Internal server error\',
  },
  NOT_FOUND: {
    fa: \'صفحه یا منبع مورد نظر یافت نشد\',
    en: \'The requested resource was not found\',
  },
  UNAUTHORIZED: {
    fa: \'احراز هویت انجام نشده است\',
    en: \'Unauthorized - Authentication required\',
  },
  FORBIDDEN: {
    fa: \'دسترسی به این منبع ممنوع است\',
    en: \'Forbidden - Access denied\',
  },
  VALIDATION_ERROR: {
    fa: \'اطلاعات وارد شده نامعتبر است\',
    en: \'Validation error\',
  },
  TOKEN_EXPIRED: {
    fa: \'توکن منقضی شده است. لطفاً دوباره وارد شوید\',
    en: \'Token expired - Please login again\',
  },
  INVALID_TOKEN: {
    fa: \'توکن نامعتبر است\',
    en: \'Invalid token\',
  },
  DATABASE_ERROR: {
    fa: \'خطا در ارتباط با پایگاه داده\',
    en: \'Database error\',
  },
  FILE_TOO_LARGE: {
    fa: \'حجم فایل بیش از حد مجاز است\',
    en: \'File too large\',
  },
  INVALID_FILE_TYPE: {
    fa: \'نوع فایل مجاز نیست\',
    en: \'Invalid file type\',
  },
  DUPLICATE_KEY: {
    fa: \'این رکورد قبلاً ثبت شده است\',
    en: \'Duplicate entry\',
  },
  FOREIGN_KEY_VIOLATION: {
    fa: \'نمی‌توان این رکورد را حذف کرد. ارجاع‌های وابسته موجود است\',
    en: \'Cannot delete - Foreign key constraint violation\',
  },
  CONFLICT: {
    fa: \'تعارض در داده‌ها\',
    en: \'Data conflict\',
  },
} as const;

// ==========================================
// ASYNC ERROR WRAPPER
// ==========================================

/**
 * Wrapper for async route handlers to catch errors
 * Usage: router.get(\'/path\', asyncHandler(async (req, res) => { ... }))
 */
export const asyncHandler = <T = Request>(
  fn: (req: T, res: Response, next: NextFunction) => Promise<any>
) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req as T, res, next)).catch(next);
  };
};

// ==========================================
// 404 NOT FOUND HANDLER
// ==========================================

/**
 * Handle 404 - Not Found errors
 * Should be placed after all routes
 */
export const notFoundHandler = (
  req: Request,
  _res: Response,
  next: NextFunction
): void => {
  const error = new NotFoundError(
    `Route not found: ${req.method} ${req.originalUrl}`
  );
  
  logError(error, \'NotFoundHandler\', {
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
  });
  
  next(error);
};

// ==========================================
// HANDLE SPECIFIC ERROR TYPES
// ==========================================

/**
 * Handle JWT errors
 */
const handleJWTError = (error: JsonWebTokenError | TokenExpiredError): AppError => {
  if (error instanceof TokenExpiredError) {
    return new UnauthorizedError(ERROR_MESSAGES.TOKEN_EXPIRED.fa);
  }
  return new UnauthorizedError(ERROR_MESSAGES.INVALID_TOKEN.fa);
};

/**
 * Handle Multer (file upload) errors
 */
const handleMulterError = (error: MulterError): AppError => {
  if (error.code === \'LIMIT_FILE_SIZE\') {
    return new AppError(ERROR_MESSAGES.FILE_TOO_LARGE.fa, StatusCodes.BAD_REQUEST);
  }
  if (error.code === \'LIMIT_UNEXPECTED_FILE\') {
    return new AppError(ERROR_MESSAGES.INVALID_FILE_TYPE.fa, StatusCodes.BAD_REQUEST);
  }
  return new AppError(error.message, StatusCodes.BAD_REQUEST);
};

/**
 * Handle PostgreSQL database errors
 */
const handleDatabaseError = (error: any): AppError => {
  // Unique violation (23505)
  if (error.code === \'23505\') {
    const field = error.detail?.match(/KATEX_INLINE_OPEN(.+)KATEX_INLINE_CLOSE=/)?.[1] || \'field\';
    return new ConflictError(
      `${ERROR_MESSAGES.DUPLICATE_KEY.fa} (${field})`
    );
  }
  
  // Foreign key violation (23503)
  if (error.code === \'23503\') {
    return new AppError(
      ERROR_MESSAGES.FOREIGN_KEY_VIOLATION.fa,
      StatusCodes.CONFLICT
    );
  }
  
  // Not null violation (23502)
  if (error.code === \'23502\') {
    const column = error.column || \'unknown\';
    return new AppError(
      `فیلد ${column} الزامی است`,
      StatusCodes.BAD_REQUEST
    );
  }
  
  // Check violation (23514)
  if (error.code === \'23514\') {
    return new AppError(
      \'مقدار وارد شده نامعتبر است\',
      StatusCodes.BAD_REQUEST
    );
  }
  
  // Connection errors
  if (error.code === \'ECONNREFUSED\' || error.code === \'ENOTFOUND\') {
    return new AppError(
      ERROR_MESSAGES.DATABASE_ERROR.fa,
      StatusCodes.SERVICE_UNAVAILABLE
    );
  }
  
  // Generic database error
  return new AppError(
    ERROR_MESSAGES.DATABASE_ERROR.fa,
    StatusCodes.INTERNAL_SERVER_ERROR
  );
};

/**
 * Handle syntax errors (invalid JSON, etc.)
 */
const handleSyntaxError = (_error: SyntaxError): AppError => {
  return new AppError(
    \'فرمت داده‌های ارسالی نامعتبر است\',
    StatusCodes.BAD_REQUEST
  );
};

// ==========================================
// SEND ERROR RESPONSE
// ==========================================

/**
 * Send error response based on environment
 * FIXED: Added safety check for headers already sent
 */
const sendErrorResponse = (
  error: AppError,
  req: Request,
  res: Response
): void => {
  // ✅ CRITICAL: Prevent sending response if headers already sent
  if (res.headersSent) {
    logger.warn(\'[sendErrorResponse] Response already sent, cannot send error\', {
      error: error.message,
      path: req.originalUrl,
    });
    return;
  }
  
  const statusCode = error.statusCode || StatusCodes.INTERNAL_SERVER_ERROR;
  
  // Base error response
  const errorResponse: IApiResponse = {
    success: false,
    error: error.message,
  };
  
  // Add validation errors if available
  if (error instanceof ValidationError && error.errors?.length > 0) {
    errorResponse.errors = error.errors;
  }
  
  // In development, include stack trace and additional info
  if (!IS_PRODUCTION) {
    (errorResponse as any).stack = error.stack;
    (errorResponse as any).statusCode = statusCode;
    (errorResponse as any).path = req.originalUrl;
    (errorResponse as any).method = req.method;
    (errorResponse as any).timestamp = new Date().toISOString();
  }
  
  res.status(statusCode).json(errorResponse);
};

// ==========================================
// MAIN ERROR HANDLER MIDDLEWARE
// ==========================================

/**
 * Central error handling middleware
 * Should be placed after all routes and other middleware
 * FIXED: Added safety check at the very start
 */
export const errorHandler = (
  err: Error | AppError,
  req: Request,
  res: Response,
  _next: NextFunction
): void => {
  // ✅ CRITICAL FIX: Prevent double response
  if (res.headersSent) {
    logger.error(\'[ErrorHandler] Headers already sent, skipping error response\', {
      error: err.message,
      path: req.originalUrl,
      method: req.method,
    });
    return;
  }
  
  let error: AppError;
  
  // Handle different error types
  if (err instanceof AppError) {
    error = err;
  } else if (err instanceof JsonWebTokenError || err instanceof TokenExpiredError) {
    error = handleJWTError(err);
  } else if (err instanceof MulterError) {
    error = handleMulterError(err);
  } else if (err instanceof SyntaxError) {
    error = handleSyntaxError(err);
  } else if (\'code\' in err) {
    // Database errors
    error = handleDatabaseError(err);
  } else {
    // Generic error
    error = new AppError(
      IS_PRODUCTION
        ? ERROR_MESSAGES.INTERNAL_SERVER_ERROR.fa
        : err.message,
      StatusCodes.INTERNAL_SERVER_ERROR
    );
  }
  
  // Log error
  logError(err, \'ErrorHandler\', {
    statusCode: error.statusCode,
    path: req.originalUrl,
    method: req.method,
    ip: req.ip,
    user: req.user?.userId,
    body: req.method !== \'GET\' ? req.body : undefined,
    query: req.query,
  });
  
  // Send error response
  sendErrorResponse(error, req, res);
};

// ==========================================
// OPERATIONAL ERROR CHECKER
// ==========================================

/**
 * Check if error is operational (known/expected) or programming error
 */
export const isOperationalError = (error: Error | AppError): boolean => {
  if (error instanceof AppError) {
    return error.isOperational;
  }
  return false;
};

// ==========================================
// HANDLE UNHANDLED REJECTIONS & EXCEPTIONS
// ==========================================

/**
 * Handle unhandled promise rejections
 * FIXED: Don\'t crash in development
 */
export const handleUnhandledRejection = (reason: Error, promise: Promise<any>): void => {
  logError(reason, \'UnhandledRejection\', {
    promise: promise.toString(),
  });
  
  // In production, gracefully shutdown
  if (IS_PRODUCTION) {
    logger.error(\'Unhandled Rejection - Shutting down gracefully...\');
    process.exit(1);
  } else {
    logger.warn(\'Unhandled Rejection in development - continuing...\', {
      reason: reason.message,
      stack: reason.stack,
    });
  }
};

/**
 * Handle uncaught exceptions
 * FIXED: Don\'t crash in development
 */
export const handleUncaughtException = (error: Error): void => {
  logError(error, \'UncaughtException\');
  
  // Always log, but only exit in production
  if (IS_PRODUCTION) {
    logger.error(\'Uncaught Exception - Shutting down immediately...\');
    process.exit(1);
  } else {
    logger.error(\'Uncaught Exception in development - continuing...\', {
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack,
      },
    });
  }
};

// ==========================================
// VALIDATION ERROR BUILDER
// ==========================================

/**
 * Build validation error from express-validator errors
 */
export const buildValidationError = (
  errors: Array<{ param: string; msg: string; value?: any }>
): ValidationError => {
  const validationErrors: IValidationError[] = errors.map((err) => ({
    field: err.param,
    message: err.msg,
  }));
  
  return new ValidationError(
    ERROR_MESSAGES.VALIDATION_ERROR.fa,
    validationErrors
  );
};

/**
 * Build validation error from Joi validation result
 */
export const buildJoiValidationError = (joiError: any): ValidationError => {
  const validationErrors: IValidationError[] = joiError.details?.map((detail: any) => ({
    field: detail.path.join(\'.\'),
    message: detail.message,
  })) || [];
  
  return new ValidationError(
    ERROR_MESSAGES.VALIDATION_ERROR.fa,
    validationErrors
  );
};

// ==========================================
// ERROR RESPONSE HELPERS
// ==========================================

/**
 * Send success response
 * FIXED: Added safety check
 */
export const sendSuccess = <T = any>(
  res: Response,
  data?: T,
  message?: string,
  statusCode: number = StatusCodes.OK,
  meta?: any
): Response => {
  if (res.headersSent) {
    logger.warn(\'[sendSuccess] Headers already sent\');
    return res;
  }
  
  const response: IApiResponse<T> = {
    success: true,
    data,
    message,
    meta,
  };
  
  return res.status(statusCode).json(response);
};

/**
 * Send error response
 * FIXED: Added safety check
 */
export const sendError = (
  res: Response,
  message: string,
  statusCode: number = StatusCodes.BAD_REQUEST,
  errors?: IValidationError[]
): Response => {
  if (res.headersSent) {
    logger.warn(\'[sendError] Headers already sent\');
    return res;
  }
  
  const response: IApiResponse = {
    success: false,
    error: message,
    errors,
  };
  
  return res.status(statusCode).json(response);
};

/**
 * Send created response (201)
 */
export const sendCreated = <T = any>(
  res: Response,
  data: T,
  message?: string
): Response => {
  return sendSuccess(res, data, message, StatusCodes.CREATED);
};

/**
 * Send no content response (204)
 */
export const sendNoContent = (res: Response): Response => {
  if (res.headersSent) {
    logger.warn(\'[sendNoContent] Headers already sent\');
    return res;
  }
  return res.status(StatusCodes.NO_CONTENT).send();
};

// ==========================================
// ATTACH HELPERS TO RESPONSE OBJECT
// ==========================================

/**
 * Middleware to attach helper methods to response object
 */
export const attachResponseHelpers = (
  _req: Request,
  res: Response,
  next: NextFunction
): void => {
  // Attach sendSuccess method
  res.sendSuccess = function <T = any>(
    data?: T,
    message?: string,
    meta?: any
  ): Response {
    return sendSuccess(res, data, message, StatusCodes.OK, meta);
  };
  
  // Attach sendError method
  res.sendError = function (
    message: string,
    statusCode: number = StatusCodes.BAD_REQUEST,
    errors?: IValidationError[]
  ): Response {
    return sendError(res, message, statusCode, errors);
  };
  
  next();
};

// ==========================================
// REQUEST ID MIDDLEWARE
// ==========================================

/**
 * Add unique request ID to each request
 * FIXED: Safe header setting with try-catch
 */
export const requestIdMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const requestId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  req.requestId = requestId;
  
  // Set header safely
  try {
    if (!res.headersSent) {
      res.setHeader(\'X-Request-ID\', requestId);
    }
  } catch (err) {
    // Silently ignore if headers already sent
    logger.debug(\'Could not set X-Request-ID header\', { requestId });
  }
  
  next();
};

// ==========================================
// REQUEST TIMING MIDDLEWARE (COMPLETELY REWRITTEN)
// ==========================================

/**
 * Track request processing time
 * FIXED: Use \'finish\' event instead of overriding res.end
 */
export const requestTimingMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const startTime = Date.now();
  req.startTime = startTime;
  
  // Listen for response finish event
  const onFinish = () => {
    const duration = Date.now() - startTime;
    
    // Log request completion
    const logData = {
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.get(\'user-agent\'),
      requestId: req.requestId,
      user: req.user?.userId,
    };
    
    // Log based on status code and duration
    if (res.statusCode >= 500) {
      logger.error(\'Request failed (5xx)\', logData);
    } else if (res.statusCode >= 400) {
      logger.warn(\'Request error (4xx)\', logData);
    } else if (duration > 1000) {
      logger.warn(\'Slow request (>1s)\', logData);
    } else {
      logger.http(`${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms`);
    }
  };
  
  // Attach finish listener
  res.on(\'finish\', onFinish);
  
  // Clean up listener on close
  res.on(\'close\', () => {
    res.off(\'finish\', onFinish);
  });
  
  next();
};

// ==========================================
// EXPORTS
// ==========================================

export default {
  asyncHandler,
  errorHandler,
  notFoundHandler,
  attachResponseHelpers,
  requestIdMiddleware,
  requestTimingMiddleware,
  sendSuccess,
  sendError,
  sendCreated,
  sendNoContent,
  buildValidationError,
  buildJoiValidationError,
  isOperationalError,
  handleUnhandledRejection,
  handleUncaughtException,
};

// ==========================================
// SETUP GLOBAL ERROR HANDLERS
// ==========================================

if (process.env.NODE_ENV !== \'test\') {
  // Handle unhandled promise rejections
  process.on(\'unhandledRejection\', handleUnhandledRejection);
  
  // Handle uncaught exceptions
  process.on(\'uncaughtException\', handleUncaughtException);
}'

node_modules\zarmind-backend\src\models\User.ts = '// ==========================================
// ZARMIND - User Model
// ==========================================

import { query } from \'../config/database\';
import { IUser, UserRole } from \'../types\';
import * as bcrypt from \'bcryptjs\';
import { BCRYPT_CONFIG } from \'../config/server\';
import { NotFoundError, ConflictError, ValidationError } from \'../types\';
import logger from \'../utils/logger\';

// ==========================================
// INTERFACES
// ==========================================

export interface ICreateUser {
  username: string;
  email: string;
  password: string;
  full_name: string;
  role?: UserRole;
  phone?: string;
  avatar?: string;
  is_active?: boolean;
}

export interface IUpdateUser {
  email?: string;
  full_name?: string;
  role?: UserRole;
  phone?: string;
  avatar?: string;
  is_active?: boolean;
}

export interface IUserFilter {
  role?: UserRole;
  is_active?: boolean;
  search?: string;
}

// ==========================================
// USER MODEL
// ==========================================

class UserModel {
  private tableName = \'users\';

  // ==========================================
  // CREATE
  // ==========================================

  /**
   * Create a new user
   */
  async create(userData: ICreateUser): Promise<IUser> {
    try {
      // Check if username already exists
      const existingUsername = await this.findByUsername(userData.username);
      if (existingUsername) {
        throw new ConflictError(`نام کاربری "${userData.username}" قبلاً ثبت شده است`);
      }

      // Check if email already exists
      const existingEmail = await this.findByEmail(userData.email);
      if (existingEmail) {
        throw new ConflictError(`ایمیل "${userData.email}" قبلاً ثبت شده است`);
      }

      // Hash password
      const hashedPassword = await this.hashPassword(userData.password);

      // Prepare user data
      const userToInsert = {
        username: userData.username,
        email: userData.email,
        password: hashedPassword,
        full_name: userData.full_name,
        role: userData.role || UserRole.EMPLOYEE,
        phone: userData.phone || null,
        avatar: userData.avatar || null,
        is_active: userData.is_active !== undefined ? userData.is_active : true,
      };

      // Insert user
      const result = await query(
        `INSERT INTO ${this.tableName} 
        (username, email, password, full_name, role, phone, avatar, is_active)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING *`,
        [
          userToInsert.username,
          userToInsert.email,
          userToInsert.password,
          userToInsert.full_name,
          userToInsert.role,
          userToInsert.phone,
          userToInsert.avatar,
          userToInsert.is_active,
        ]
      );

      const user = result.rows[0];
      logger.info(`User created: ${user.username} (${user.id})`);

      return user;
    } catch (error) {
      logger.error(\'Error creating user:\', error);
      throw error;
    }
  }

  // ==========================================
  // READ
  // ==========================================

  /**
   * Find user by ID
   */
  async findById(id: string): Promise<IUser | null> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE id = $1`,
      [id]
    );

    return result.rows[0] || null;
  }

  /**
   * Find user by username
   */
  async findByUsername(username: string): Promise<IUser | null> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE username = $1`,
      [username]
    );

    return result.rows[0] || null;
  }

  /**
   * Find user by email
   */
  async findByEmail(email: string): Promise<IUser | null> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE email = $1`,
      [email]
    );

    return result.rows[0] || null;
  }

  /**
   * Get all users with optional filters
   */
  async findAll(filters?: IUserFilter): Promise<IUser[]> {
    let sql = `SELECT * FROM ${this.tableName} WHERE 1=1`;
    const params: any[] = [];
    let paramIndex = 1;

    // Apply filters
    if (filters?.role) {
      sql += ` AND role = $${paramIndex}`;
      params.push(filters.role);
      paramIndex++;
    }

    if (filters?.is_active !== undefined) {
      sql += ` AND is_active = $${paramIndex}`;
      params.push(filters.is_active);
      paramIndex++;
    }

    if (filters?.search) {
      sql += ` AND (
        username ILIKE $${paramIndex} OR 
        email ILIKE $${paramIndex} OR 
        full_name ILIKE $${paramIndex}
      )`;
      params.push(`%${filters.search}%`);
      paramIndex++;
    }

    sql += ` ORDER BY created_at DESC`;

    const result = await query(sql, params);
    return result.rows;
  }

  /**
   * Get users with pagination
   */
  async findWithPagination(
    page: number = 1,
    limit: number = 20,
    filters?: IUserFilter
  ): Promise<{ users: IUser[]; total: number; page: number; limit: number }> {
    const offset = (page - 1) * limit;

    let countSql = `SELECT COUNT(*) as count FROM ${this.tableName} WHERE 1=1`;
    let dataSql = `SELECT * FROM ${this.tableName} WHERE 1=1`;
    const params: any[] = [];
    let paramIndex = 1;

    // Apply filters
    if (filters?.role) {
      const roleFilter = ` AND role = $${paramIndex}`;
      countSql += roleFilter;
      dataSql += roleFilter;
      params.push(filters.role);
      paramIndex++;
    }

    if (filters?.is_active !== undefined) {
      const activeFilter = ` AND is_active = $${paramIndex}`;
      countSql += activeFilter;
      dataSql += activeFilter;
      params.push(filters.is_active);
      paramIndex++;
    }

    if (filters?.search) {
      const searchFilter = ` AND (
        username ILIKE $${paramIndex} OR 
        email ILIKE $${paramIndex} OR 
        full_name ILIKE $${paramIndex}
      )`;
      countSql += searchFilter;
      dataSql += searchFilter;
      params.push(`%${filters.search}%`);
      paramIndex++;
    }

    dataSql += ` ORDER BY created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    const dataParams = [...params, limit, offset];

    // Execute queries
    const [countResult, dataResult] = await Promise.all([
      query(countSql, params),
      query(dataSql, dataParams),
    ]);

    const total = parseInt(countResult.rows[0]?.count || \'0\', 10);

    return {
      users: dataResult.rows,
      total,
      page,
      limit,
    };
  }

  /**
   * Get users by role
   */
  async findByRole(role: UserRole): Promise<IUser[]> {
    const result = await query(
      `SELECT * FROM ${this.tableName} WHERE role = $1 ORDER BY created_at DESC`,
      [role]
    );

    return result.rows;
  }

  /**
   * Get active users count
   */
  async getActiveUsersCount(): Promise<number> {
    const result = await query(
      `SELECT COUNT(*) as count FROM ${this.tableName} WHERE is_active = true`
    );

    return parseInt(result.rows[0]?.count || \'0\', 10);
  }

  /**
   * Get users count by role
   */
  async getUsersCountByRole(): Promise<Record<UserRole, number>> {
    const result = await query(
      `SELECT role, COUNT(*) as count 
     FROM ${this.tableName} 
     GROUP BY role`
    );

    const counts: Record<UserRole, number> = {
      [UserRole.ADMIN]: 0,
      [UserRole.MANAGER]: 0,
      [UserRole.EMPLOYEE]: 0,
      [UserRole.VIEWER]: 0,
    };

    result.rows.forEach((row: { role: string; count: string }) => {
      const role = row.role as UserRole;
      if (role in counts) {
        counts[role] = parseInt(row.count, 10);
      }
    });

    return counts;
  }

  // ==========================================
  // UPDATE
  // ==========================================

  /**
   * Update user by ID
   */
  async update(id: string, updateData: IUpdateUser): Promise<IUser> {
    const user = await this.findById(id);
    if (!user) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    // Check if email is being changed and if it\'s already taken
    if (updateData.email && updateData.email !== user.email) {
      const existingEmail = await this.findByEmail(updateData.email);
      if (existingEmail) {
        throw new ConflictError(`ایمیل "${updateData.email}" قبلاً ثبت شده است`);
      }
    }

    // Build update query
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    if (updateData.email !== undefined) {
      fields.push(`email = $${paramIndex}`);
      values.push(updateData.email);
      paramIndex++;
    }

    if (updateData.full_name !== undefined) {
      fields.push(`full_name = $${paramIndex}`);
      values.push(updateData.full_name);
      paramIndex++;
    }

    if (updateData.role !== undefined) {
      fields.push(`role = $${paramIndex}`);
      values.push(updateData.role);
      paramIndex++;
    }

    if (updateData.phone !== undefined) {
      fields.push(`phone = $${paramIndex}`);
      values.push(updateData.phone);
      paramIndex++;
    }

    if (updateData.avatar !== undefined) {
      fields.push(`avatar = $${paramIndex}`);
      values.push(updateData.avatar);
      paramIndex++;
    }

    if (updateData.is_active !== undefined) {
      fields.push(`is_active = $${paramIndex}`);
      values.push(updateData.is_active);
      paramIndex++;
    }

    if (fields.length === 0) {
      return user; // No changes
    }

    fields.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id);

    const sql = `
      UPDATE ${this.tableName} 
      SET ${fields.join(\', \')} 
      WHERE id = $${paramIndex}
      RETURNING *
    `;

    const result = await query(sql, values);
    const updatedUser = result.rows[0];

    logger.info(`User updated: ${updatedUser.username} (${updatedUser.id})`);

    return updatedUser;
  }

  /**
   * Update user password
   */
  async updatePassword(id: string, newPassword: string): Promise<void> {
    const hashedPassword = await this.hashPassword(newPassword);

    await query(
      `UPDATE ${this.tableName} 
       SET password = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2`,
      [hashedPassword, id]
    );

    logger.info(`Password updated for user ID: ${id}`);
  }

  /**
   * Update last login timestamp
   */
  async updateLastLogin(id: string): Promise<void> {
    await query(
      `UPDATE ${this.tableName} 
       SET last_login = CURRENT_TIMESTAMP 
       WHERE id = $1`,
      [id]
    );
  }

  /**
   * Update user avatar
   */
  async updateAvatar(id: string, avatarUrl: string): Promise<IUser> {
    const result = await query(
      `UPDATE ${this.tableName} 
       SET avatar = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2
       RETURNING *`,
      [avatarUrl, id]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    return result.rows[0];
  }

  /**
   * Activate/Deactivate user
   */
  async setActiveStatus(id: string, isActive: boolean): Promise<IUser> {
    const result = await query(
      `UPDATE ${this.tableName} 
       SET is_active = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2
       RETURNING *`,
      [isActive, id]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    const user = result.rows[0];
    logger.info(`User ${isActive ? \'activated\' : \'deactivated\'}: ${user.username} (${user.id})`);

    return user;
  }

  // ==========================================
  // DELETE
  // ==========================================

  /**
   * Delete user by ID (soft delete - deactivate)
   */
  async softDelete(id: string): Promise<void> {
    await this.setActiveStatus(id, false);
  }

  /**
   * Delete user by ID (hard delete - permanent)
   */
  async hardDelete(id: string): Promise<void> {
    const result = await query(
      `DELETE FROM ${this.tableName} WHERE id = $1 RETURNING id, username`,
      [id]
    );

    if (result.rows.length === 0) {
      throw new NotFoundError(\'کاربر یافت نشد\');
    }

    logger.warn(`User permanently deleted: ${result.rows[0].username} (${id})`);
  }

  // ==========================================
  // AUTHENTICATION HELPERS
  // ==========================================

  /**
   * Hash password using bcrypt
   */
  async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, BCRYPT_CONFIG.ROUNDS);
  }

  /**
   * Compare password with hash
   */
  async comparePassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  /**
   * Verify user credentials
   */
  async verifyCredentials(username: string, password: string): Promise<IUser | null> {
    const user = await this.findByUsername(username);

    if (!user) {
      return null;
    }

    if (!user.is_active) {
      throw new ValidationError(\'حساب کاربری غیرفعال است\');
    }

    const isPasswordValid = await this.comparePassword(password, user.password);

    if (!isPasswordValid) {
      return null;
    }

    // Update last login
    await this.updateLastLogin(user.id);

    return user;
  }

  // ==========================================
  // UTILITY METHODS
  // ==========================================

  /**
   * Check if user exists by ID
   */
  async exists(id: string): Promise<boolean> {
    const result = await query(
      `SELECT EXISTS(SELECT 1 FROM ${this.tableName} WHERE id = $1)`,
      [id]
    );

    return result.rows[0]?.exists || false;
  }

  /**
   * Check if username is available
   */
  async isUsernameAvailable(username: string): Promise<boolean> {
    const user = await this.findByUsername(username);
    return !user;
  }

  /**
   * Check if email is available
   */
  async isEmailAvailable(email: string): Promise<boolean> {
    const user = await this.findByEmail(email);
    return !user;
  }

  /**
   * Get user without password field
   */
  async findByIdSafe(id: string): Promise<Omit<IUser, \'password\'> | null> {
    const result = await query(
      `SELECT id, username, email, full_name, role, phone, avatar, 
              is_active, last_login, created_at, updated_at 
       FROM ${this.tableName} 
       WHERE id = $1`,
      [id]
    );

    return result.rows[0] || null;
  }

  /**
   * Get all users without password field
   */
  async findAllSafe(filters?: IUserFilter): Promise<Omit<IUser, \'password\'>[]> {
    const users = await this.findAll(filters);
    return users.map((user) => this.omitPassword(user));
  }

  /**
   * Remove password from user object
   */
  omitPassword(user: IUser): Omit<IUser, \'password\'> {
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  /**
   * Get user statistics
   */
  async getStatistics(): Promise<{
    total: number;
    active: number;
    inactive: number;
    byRole: Record<UserRole, number>;
  }> {
    const [totalResult, activeResult, byRoleResult] = await Promise.all([
      query(`SELECT COUNT(*) as count FROM ${this.tableName}`),
      query(
        `SELECT COUNT(*) as count FROM ${this.tableName} WHERE is_active = true`
      ),
      this.getUsersCountByRole(),
    ]);

    const total = parseInt(totalResult.rows[0]?.count || \'0\', 10);
    const active = parseInt(activeResult.rows[0]?.count || \'0\', 10);

    return {
      total,
      active,
      inactive: total - active,
      byRole: byRoleResult,
    };
  }
}

// ==========================================
// EXPORT SINGLETON INSTANCE
// ==========================================

export default new UserModel();'

node_modules\zarmind-backend\src\routes\auth.routes.ts = '// ==========================================
// ZARMIND - Authentication Routes
// ==========================================

import { Router } from \'express\';
import authController from \'../controllers/authController\';
import { validators, validate } from \'../middleware/validation.middleware\';
import {
  authenticate,
  optionalAuthenticate,
  isAdmin,
  checkAccountLock,
} from \'../middleware/auth.middleware\';
import { body, param, query } from \'express-validator\';

const router = Router();

// ==========================================
// PUBLIC ROUTES (No Authentication Required)
// ==========================================

/**
 * @route   POST /api/auth/login
 * @desc    Login with username and password
 * @access  Public
 */
router.post(
  \'/login\',
  checkAccountLock(\'username\'),
  validators.login,
  validate,
  authController.login
);

/**
 * @route   POST /api/auth/login-email
 * @desc    Login with email and password
 * @access  Public
 */
router.post(
  \'/login-email\',
  checkAccountLock(\'email\'),
  [
    body(\'email\')
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\')
      .normalizeEmail(),
    body(\'password\')
      .notEmpty()
      .withMessage(\'رمز عبور الزامی است\'),
    body(\'rememberMe\')
      .optional()
      .isBoolean()
      .toBoolean(),
  ],
  validate,
  authController.loginWithEmail
);

/**
 * @route   POST /api/auth/register
 * @desc    Register new user
 * @access  Public (or can be restricted to Admin only)
 */
router.post(
  \'/register\',
  validators.register,
  validate,
  authController.register
);

/**
 * @route   POST /api/auth/refresh
 * @desc    Refresh access token using refresh token
 * @access  Public
 */
router.post(
  \'/refresh\',
  [
    body(\'refreshToken\')
      .notEmpty()
      .withMessage(\'توکن بازیابی الزامی است\'),
  ],
  validate,
  authController.refreshToken
);

/**
 * @route   POST /api/auth/validate
 * @desc    Validate access token
 * @access  Public
 */
router.post(
  \'/validate\',
  [
    body(\'token\')
      .notEmpty()
      .withMessage(\'توکن الزامی است\'),
  ],
  validate,
  authController.validateToken
);

/**
 * @route   GET /api/auth/status
 * @desc    Get authentication status
 * @access  Public (with optional authentication)
 */
router.get(
  \'/status\',
  optionalAuthenticate,
  authController.getAuthStatus
);

// ==========================================
// PASSWORD RESET ROUTES (Public)
// ==========================================

/**
 * @route   POST /api/auth/forgot-password
 * @desc    Request password reset (sends email with reset token)
 * @access  Public
 */
router.post(
  \'/forgot-password\',
  [
    body(\'email\')
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\')
      .normalizeEmail(),
  ],
  validate,
  authController.forgotPassword
);

/**
 * @route   POST /api/auth/reset-password
 * @desc    Reset password using reset token
 * @access  Public
 */
router.post(
  \'/reset-password\',
  [
    body(\'resetToken\')
      .notEmpty()
      .withMessage(\'توکن بازیابی الزامی است\'),
    body(\'newPassword\')
      .isLength({ min: 6, max: 128 })
      .withMessage(\'رمز عبور جدید باید بین 6 تا 128 کاراکتر باشد\'),
    body(\'confirmPassword\')
      .custom((value, { req }) => {
        if (value !== req.body.newPassword) {
          throw new Error(\'تکرار رمز عبور مطابقت ندارد\');
        }
        return true;
      }),
  ],
  validate,
  authController.resetPassword
);

// ==========================================
// AVAILABILITY CHECK ROUTES (Public)
// ==========================================

/**
 * @route   GET /api/auth/check-username/:username
 * @desc    Check if username is available
 * @access  Public
 */
router.get(
  \'/check-username/:username\',
  [
    param(\'username\')
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage(\'نام کاربری باید بین 3 تا 50 کاراکتر باشد\'),
  ],
  validate,
  authController.checkUsername
);

/**
 * @route   GET /api/auth/check-email/:email
 * @desc    Check if email is available
 * @access  Public
 */
router.get(
  \'/check-email/:email\',
  [
    param(\'email\')
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\'),
  ],
  validate,
  authController.checkEmail
);

/**
 * @route   POST /api/auth/check-availability
 * @desc    Check username and/or email availability
 * @access  Public
 */
router.post(
  \'/check-availability\',
  [
    body(\'username\')
      .optional()
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage(\'نام کاربری باید بین 3 تا 50 کاراکتر باشد\'),
    body(\'email\')
      .optional()
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\'),
  ],
  validate,
  authController.checkAvailability
);

// ==========================================
// PROTECTED ROUTES (Authentication Required)
// ==========================================

/**
 * @route   POST /api/auth/logout
 * @desc    Logout and blacklist token
 * @access  Private
 */
router.post(
  \'/logout\',
  authenticate,
  authController.logout
);

/**
 * @route   GET /api/auth/verify
 * @desc    Verify if user is authenticated
 * @access  Private
 */
router.get(
  \'/verify\',
  authenticate,
  authController.verifyAuthentication
);

// ==========================================
// PROFILE ROUTES (Private)
// ==========================================

/**
 * @route   GET /api/auth/me
 * @desc    Get current user profile
 * @access  Private
 */
router.get(
  \'/me\',
  authenticate,
  authController.getProfile
);

/**
 * @route   PUT /api/auth/me
 * @desc    Update current user profile
 * @access  Private
 */
router.put(
  \'/me\',
  authenticate,
  [
    body(\'full_name\')
      .optional()
      .trim()
      .isLength({ min: 2, max: 255 })
      .withMessage(\'نام کامل باید بین 2 تا 255 کاراکتر باشد\'),
    body(\'phone\')
      .optional()
      .trim()
      .isMobilePhone(\'fa-IR\')
      .withMessage(\'شماره تلفن نامعتبر است\'),
    body(\'email\')
      .optional()
      .trim()
      .isEmail()
      .withMessage(\'ایمیل نامعتبر است\')
      .normalizeEmail(),
    body(\'avatar\')
      .optional()
      .trim()
      .isURL()
      .withMessage(\'آدرس تصویر نامعتبر است\'),
  ],
  validate,
  authController.updateProfile
);

/**
 * @route   PUT /api/auth/avatar
 * @desc    Update user avatar
 * @access  Private
 */
router.put(
  \'/avatar\',
  authenticate,
  // File upload middleware would go here
  [
    body(\'avatar\')
      .optional()
      .trim()
      .isURL()
      .withMessage(\'آدرس تصویر نامعتبر است\'),
  ],
  validate,
  authController.updateAvatar
);

// ==========================================
// PASSWORD MANAGEMENT ROUTES (Private)
// ==========================================

/**
 * @route   PUT /api/auth/change-password
 * @desc    Change password (requires current password)
 * @access  Private
 */
router.put(
  \'/change-password\',
  authenticate,
  validators.updatePassword,
  validate,
  authController.changePassword
);

// ==========================================
// SESSION MANAGEMENT ROUTES (Private)
// ==========================================

/**
 * @route   GET /api/auth/sessions
 * @desc    Get all active sessions
 * @access  Private
 */
router.get(
  \'/sessions\',
  authenticate,
  authController.getSessions
);

/**
 * @route   DELETE /api/auth/sessions
 * @desc    Logout from all devices
 * @access  Private
 */
router.delete(
  \'/sessions\',
  authenticate,
  authController.revokeSessions
);

// ==========================================
// SECURITY ROUTES (Private)
// ==========================================

/**
 * @route   GET /api/auth/login-history
 * @desc    Get login history
 * @access  Private
 */
router.get(
  \'/login-history\',
  authenticate,
  [
    query(\'limit\')
      .optional()
      .isInt({ min: 1, max: 100 })
      .withMessage(\'حد مجاز باید بین 1 تا 100 باشد\')
      .toInt(),
  ],
  validate,
  authController.getLoginHistory
);

/**
 * @route   POST /api/auth/enable-2fa
 * @desc    Enable two-factor authentication
 * @access  Private
 */
router.post(
  \'/enable-2fa\',
  authenticate,
  authController.enableTwoFactor
);

/**
 * @route   POST /api/auth/verify-2fa
 * @desc    Verify two-factor authentication code
 * @access  Private
 */
router.post(
  \'/verify-2fa\',
  authenticate,
  [
    body(\'code\')
      .notEmpty()
      .withMessage(\'کد تایید الزامی است\')
      .isLength({ min: 6, max: 6 })
      .withMessage(\'کد تایید باید 6 رقم باشد\'),
  ],
  validate,
  authController.verifyTwoFactor
);

// ==========================================
// ADMIN ROUTES (Admin Only)
// ==========================================

/**
 * @route   PUT /api/auth/reset-password/:userId
 * @desc    Admin reset user password
 * @access  Private (Admin only)
 */
router.put(
  \'/reset-password/:userId\',
  authenticate,
  isAdmin,
  [
    param(\'userId\')
      .isUUID()
      .withMessage(\'شناسه کاربر نامعتبر است\'),
    body(\'newPassword\')
      .isLength({ min: 6, max: 128 })
      .withMessage(\'رمز عبور جدید باید بین 6 تا 128 کاراکتر باشد\'),
  ],
  validate,
  authController.adminResetPassword
);

// ==========================================
// EXPORTS
// ==========================================

export default router;'

node_modules\zarmind-backend\src\services\authService.ts = '// ==========================================
// ZARMIND - Authentication Service
// ==========================================

import UserModel, { ICreateUser } from \'../models/User\';
import {
  IUser,
  IAuthTokens,
  ITokenPayload,
  UnauthorizedError,
  ValidationError,
  ConflictError,
  NotFoundError,
} from \'../types\';
import {TokenExpiredError} from \'jsonwebtoken\';
import {
  generateAccessToken,
  generateRefreshToken,
  verifyRefreshToken,
  blacklistToken,
  trackFailedLogin,
  resetLoginAttempts,
  isAccountLocked,
} from \'../middleware/auth.middleware\';
import logger, { logAuth, logSecurity } from \'../utils/logger\';
import { sanitizePhoneNumber } from \'../utils/helpers\';

// ==========================================
// INTERFACES
// ==========================================

export interface ILoginCredentials {
  username: string;
  password: string;
  rememberMe?: boolean;
}

export interface IRegisterData extends ICreateUser {
  confirmPassword?: string;
}

export interface ILoginResponse {
  user: Omit<IUser, \'password\'>;
  tokens: IAuthTokens;
}

export interface IChangePasswordData {
  userId: string;
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}

export interface IResetPasswordData {
  userId: string;
  newPassword: string;
}

export interface IRefreshTokenData {
  refreshToken: string;
}

// ==========================================
// AUTHENTICATION SERVICE
// ==========================================

class AuthService {
  // ==========================================
  // LOGIN
  // ==========================================

  /**
   * Authenticate user and return tokens
   */
  async login(
    credentials: ILoginCredentials,
    ipAddress?: string,
    userAgent?: string
  ): Promise<ILoginResponse> {
    try {
      const { username, password, rememberMe } = credentials;

      // Sanitize username
      const sanitizedUsername = username.trim().toLowerCase();

      // Check if account is locked
      if (isAccountLocked(sanitizedUsername)) {
        logSecurity(\'Locked account login attempt\', \'medium\', {
          username: sanitizedUsername,
          ip: ipAddress,
        });

        throw new UnauthorizedError(
          \'حساب کاربری شما به دلیل تلاش‌های متعدد ناموفق قفل شده است. لطفاً 15 دقیقه صبر کنید\'
        );
      }

      // Verify credentials
      const user = await UserModel.verifyCredentials(sanitizedUsername, password);

      if (!user) {
        // Track failed login attempt
        trackFailedLogin(sanitizedUsername);

        logAuth(\'failed_login\', sanitizedUsername, ipAddress, userAgent);

        throw new UnauthorizedError(\'نام کاربری یا رمز عبور اشتباه است\');
      }

      // Reset failed login attempts on successful login
      resetLoginAttempts(sanitizedUsername);

      // Generate tokens
      const tokens = this.generateTokens(user, rememberMe);

      // Log successful login
      logAuth(\'login\', user.username, ipAddress, userAgent);

      logger.info(\'User logged in successfully\', {
        userId: user.id,
        username: user.username,
        role: user.role,
        ip: ipAddress,
      });

      return {
        user: UserModel.omitPassword(user),
        tokens,
      };
    } catch (error) {
      logger.error(\'Login error:\', error);
      throw error;
    }
  }

  /**
   * Login with email instead of username
   */
  async loginWithEmail(
    email: string,
    password: string,
    ipAddress?: string,
    userAgent?: string
  ): Promise<ILoginResponse> {
    try {
      const sanitizedEmail = email.trim().toLowerCase();

      // Check if account is locked
      if (isAccountLocked(sanitizedEmail)) {
        throw new UnauthorizedError(
          \'حساب کاربری شما به دلیل تلاش‌های متعدد ناموفق قفل شده است. لطفاً 15 دقیقه صبر کنید\'
        );
      }

      // Find user by email
      const user = await UserModel.findByEmail(sanitizedEmail);

      if (!user) {
        trackFailedLogin(sanitizedEmail);
        throw new UnauthorizedError(\'ایمیل یا رمز عبور اشتباه است\');
      }

      // Verify password
      const isPasswordValid = await UserModel.comparePassword(password, user.password);

      if (!isPasswordValid) {
        trackFailedLogin(sanitizedEmail);
        throw new UnauthorizedError(\'ایمیل یا رمز عبور اشتباه است\');
      }

      if (!user.is_active) {
        throw new UnauthorizedError(\'حساب کاربری غیرفعال است\');
      }

      // Reset failed attempts and update last login
      resetLoginAttempts(sanitizedEmail);
      await UserModel.updateLastLogin(user.id);

      // Generate tokens
      const tokens = this.generateTokens(user);

      logAuth(\'login\', user.username, ipAddress, userAgent);

      return {
        user: UserModel.omitPassword(user),
        tokens,
      };
    } catch (error) {
      logger.error(\'Login with email error:\', error);
      throw error;
    }
  }

  // ==========================================
  // REGISTER
  // ==========================================

  /**
   * Register new user
   */
  async register(
    registerData: IRegisterData,
    ipAddress?: string,
    userAgent?: string
  ): Promise<ILoginResponse> {
    try {
      // Validate passwords match
      if (registerData.password !== registerData.confirmPassword) {
        throw new ValidationError(\'رمز عبور و تکرار آن مطابقت ندارند\');
      }

      // Sanitize data
      const sanitizedData: ICreateUser = {
        username: registerData.username.trim().toLowerCase(),
        email: registerData.email.trim().toLowerCase(),
        password: registerData.password,
        full_name: registerData.full_name.trim(),
        role: registerData.role,
        phone: registerData.phone ? sanitizePhoneNumber(registerData.phone) : undefined,
        avatar: registerData.avatar,
        is_active: registerData.is_active !== undefined ? registerData.is_active : true,
      };

      // Validate username availability
      const usernameExists = await UserModel.findByUsername(sanitizedData.username);
      if (usernameExists) {
        throw new ConflictError(`نام کاربری "${sanitizedData.username}" قبلاً ثبت شده است`);
      }

      // Validate email availability
      const emailExists = await UserModel.findByEmail(sanitizedData.email);
      if (emailExists) {
        throw new ConflictError(`ایمیل "${sanitizedData.email}" قبلاً ثبت شده است`);
      }

      // Create user
      const user = await UserModel.create(sanitizedData);

      // Generate tokens
      const tokens = this.generateTokens(user);

      // Log registration
      logAuth(\'register\', user.username, ipAddress, userAgent);

      logger.info(\'User registered successfully\', {
        userId: user.id,
        username: user.username,
        email: user.email,
        role: user.role,
      });

      return {
        user: UserModel.omitPassword(user),
        tokens,
      };
    } catch (error) {
      logger.error(\'Registration error:\', error);
      throw error;
    }
  }

  // ==========================================
  // LOGOUT
  // ==========================================

  /**
   * Logout user and blacklist token
   */
  async logout(
    accessToken: string,
    userId?: string,
    ipAddress?: string,
    userAgent?: string
  ): Promise<void> {
    try {
      // Add token to blacklist
      if (accessToken) {
        blacklistToken(accessToken);
      }

      if (userId) {
        const user = await UserModel.findById(userId);
        if (user) {
          logAuth(\'logout\', user.username, ipAddress, userAgent);
        }

        logger.info(\'User logged out\', {
          userId,
          ip: ipAddress,
        });
      }
    } catch (error) {
      logger.error(\'Logout error:\', error);
      throw error;
    }
  }

  // ==========================================
  // TOKEN OPERATIONS
  // ==========================================

  /**
   * Generate access and refresh tokens
   */
  generateTokens(user: IUser, _rememberMe?: boolean): IAuthTokens {
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    return {
      accessToken,
      refreshToken,
    };
  }

  /**
   * Refresh access token using refresh token
   */
  async refreshAccessToken(refreshTokenData: IRefreshTokenData): Promise<IAuthTokens> {
    try {
      const { refreshToken } = refreshTokenData;

      // Verify refresh token
      const decoded = verifyRefreshToken(refreshToken);

      // Get user
      const user = await UserModel.findById(decoded.userId);

      if (!user) {
        throw new UnauthorizedError(\'کاربر یافت نشد\');
      }

      if (!user.is_active) {
        throw new UnauthorizedError(\'حساب کاربری غیرفعال است\');
      }

      // Generate new tokens
      const tokens = this.generateTokens(user);

      logger.info(\'Access token refreshed\', {
        userId: user.id,
        username: user.username,
      });

      return tokens;
    } catch (error) {
      logger.error(\'Token refresh error:\', error);
      throw error;
    }
  }

  /**
   * Validate access token
   */
  async validateToken(token: string): Promise<ITokenPayload> {
    try {
      // This would use the verifyToken from middleware
      // For now, we\'ll import jwt directly
      const jwt = require(\'jsonwebtoken\');
      const { JWT_CONFIG } = require(\'../config/server\');

      const decoded = jwt.verify(token, JWT_CONFIG.SECRET) as ITokenPayload;

      // Verify user still exists and is active
      const user = await UserModel.findById(decoded.userId);

      if (!user || !user.is_active) {
        throw new UnauthorizedError(\'توکن نامعتبر است\');
      }

      return decoded;
    } catch (error) {
      throw new UnauthorizedError(\'توکن نامعتبر یا منقضی شده است\');
    }
  }

  // ==========================================
  // PASSWORD MANAGEMENT
  // ==========================================

  /**
   * Change user password
   */
  async changePassword(passwordData: IChangePasswordData): Promise<void> {
    try {
      const { userId, currentPassword, newPassword, confirmPassword } = passwordData;

      // Validate new passwords match
      if (newPassword !== confirmPassword) {
        throw new ValidationError(\'رمز عبور جدید و تکرار آن مطابقت ندارند\');
      }

      // Validate new password is different from current
      if (currentPassword === newPassword) {
        throw new ValidationError(\'رمز عبور جدید باید با رمز عبور فعلی متفاوت باشد\');
      }

      // Get user
      const user = await UserModel.findById(userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      // Verify current password
      const isCurrentPasswordValid = await UserModel.comparePassword(
        currentPassword,
        user.password
      );

      if (!isCurrentPasswordValid) {
        throw new UnauthorizedError(\'رمز عبور فعلی اشتباه است\');
      }

      // Update password
      await UserModel.updatePassword(userId, newPassword);

      logger.info(\'Password changed successfully\', {
        userId,
        username: user.username,
      });
    } catch (error) {
      logger.error(\'Change password error:\', error);
      throw error;
    }
  }

  /**
   * Reset password (admin function - no current password required)
   */
  async resetPassword(resetData: IResetPasswordData): Promise<void> {
    try {
      const { userId, newPassword } = resetData;

      // Get user
      const user = await UserModel.findById(userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      // Update password
      await UserModel.updatePassword(userId, newPassword);

      logger.warn(\'Password reset by admin\', {
        userId,
        username: user.username,
      });
    } catch (error) {
      logger.error(\'Reset password error:\', error);
      throw error;
    }
  }

  /**
   * Request password reset (generate reset token)
   * Note: This is a placeholder - in production, you\'d send an email with reset link
   */
  async requestPasswordReset(email: string): Promise<{ message: string; resetToken?: string }> {
    try {
      const user = await UserModel.findByEmail(email.trim().toLowerCase());

      if (!user) {
        // Don\'t reveal if user exists
        return {
          message: \'اگر این ایمیل در سیستم موجود باشد، لینک بازیابی رمز عبور برای شما ارسال می‌شود\',
        };
      }

      // Generate reset token (valid for 1 hour)
      const jwt = require(\'jsonwebtoken\');
      const { JWT_CONFIG } = require(\'../config/server\');

      const resetToken = jwt.sign(
        { userId: user.id, type: \'password_reset\' },
        JWT_CONFIG.SECRET,
        { expiresIn: \'1h\' }
      );

      // In production: Send email with reset link
      // await emailService.sendPasswordResetEmail(user.email, resetToken);

      logger.info(\'Password reset requested\', {
        userId: user.id,
        email: user.email,
      });

      // In development, return token (remove in production)
      if (process.env.NODE_ENV === \'development\') {
        return {
          message: \'لینک بازیابی رمز عبور برای شما ارسال شد\',
          resetToken,
        };
      }

      return {
        message: \'لینک بازیابی رمز عبور برای شما ارسال شد\',
      };
    } catch (error) {
      logger.error(\'Request password reset error:\', error);
      throw error;
    }
  }

  /**
   * Confirm password reset with token
   */
  async confirmPasswordReset(resetToken: string, newPassword: string): Promise<void> {
    try {
      const jwt = require(\'jsonwebtoken\');
      const { JWT_CONFIG } = require(\'../config/server\');

      // Verify reset token
      const decoded = jwt.verify(resetToken, JWT_CONFIG.SECRET) as {
        userId: string;
        type: string;
      };

      if (decoded.type !== \'password_reset\') {
        throw new UnauthorizedError(\'توکن بازیابی نامعتبر است\');
      }

      // Get user
      const user = await UserModel.findById(decoded.userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      // Update password
      await UserModel.updatePassword(decoded.userId, newPassword);

      logger.info(\'Password reset confirmed\', {
        userId: user.id,
        username: user.username,
      });
    } catch (error) {
      if (error instanceof TokenExpiredError) {
        throw new UnauthorizedError(\'لینک بازیابی منقضی شده است. لطفاً دوباره درخواست دهید\');
      }
      logger.error(\'Confirm password reset error:\', error);
      throw error;
    }
  }

  // ==========================================
  // USER PROFILE
  // ==========================================

  /**
   * Get current user profile
   */
  async getProfile(userId: string): Promise<Omit<IUser, \'password\'>> {
    try {
      const user = await UserModel.findByIdSafe(userId);

      if (!user) {
        throw new NotFoundError(\'کاربر یافت نشد\');
      }

      return user;
    } catch (error) {
      logger.error(\'Get profile error:\', error);
      throw error;
    }
  }

  /**
   * Update user profile
   */
  async updateProfile(
    userId: string,
    updateData: {
      full_name?: string;
      phone?: string;
      email?: string;
      avatar?: string;
    }
  ): Promise<Omit<IUser, \'password\'>> {
    try {
      // Sanitize phone if provided
      if (updateData.phone) {
        updateData.phone = sanitizePhoneNumber(updateData.phone);
      }

      // Sanitize email if provided
      if (updateData.email) {
        updateData.email = updateData.email.trim().toLowerCase();
      }

      const updatedUser = await UserModel.update(userId, updateData);

      logger.info(\'Profile updated\', {
        userId,
        username: updatedUser.username,
      });

      return UserModel.omitPassword(updatedUser);
    } catch (error) {
      logger.error(\'Update profile error:\', error);
      throw error;
    }
  }

  // ==========================================
  // ACCOUNT VERIFICATION
  // ==========================================

  /**
   * Check if username is available
   */
  async checkUsernameAvailability(username: string): Promise<boolean> {
    const sanitizedUsername = username.trim().toLowerCase();
    return await UserModel.isUsernameAvailable(sanitizedUsername);
  }

  /**
   * Check if email is available
   */
  async checkEmailAvailability(email: string): Promise<boolean> {
    const sanitizedEmail = email.trim().toLowerCase();
    return await UserModel.isEmailAvailable(sanitizedEmail);
  }

  /**
   * Verify user exists and is active
   */
  async verifyUserActive(userId: string): Promise<boolean> {
    const user = await UserModel.findById(userId);
    return user !== null && user.is_active;
  }

  // ==========================================
  // SESSION MANAGEMENT
  // ==========================================

  /**
   * Get all active sessions for user (placeholder)
   * In production, track sessions in Redis
   */
  async getActiveSessions(_userId: string): Promise<any[]> {
    // This would query Redis or session store
    // For now, return empty array
    return [];
  }

  /**
   * Revoke all sessions for user (force logout everywhere)
   */
  async revokeAllSessions(userId: string): Promise<void> {
    try {
      // In production, clear all sessions from Redis
      // and blacklist all active tokens

      logger.warn(\'All sessions revoked for user\', { userId });
    } catch (error) {
      logger.error(\'Revoke sessions error:\', error);
      throw error;
    }
  }

  // ==========================================
  // SECURITY
  // ==========================================

  /**
   * Get user\'s recent login history (placeholder)
   */
  async getLoginHistory(_userId: string, _limit: number = 10): Promise<any[]> {
    // This would query audit logs
    // For now, return empty array
    return [];
  }

  /**
   * Enable two-factor authentication (placeholder)
   */
  async enableTwoFactor(_userId: string): Promise<{ secret: string; qrCode: string }> {
    // This would setup 2FA with libraries like speakeasy
    throw new Error(\'Two-factor authentication not implemented yet\');
  }

  /**
   * Verify two-factor code (placeholder)
   */
  async verifyTwoFactor(_userId: string, _code: string): Promise<boolean> {
    // This would verify 2FA code
    throw new Error(\'Two-factor authentication not implemented yet\');
  }
}

// ==========================================
// EXPORT SINGLETON INSTANCE
// ==========================================

export default new AuthService();'

